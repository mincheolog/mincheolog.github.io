<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="/author/ardo/feed.xml" rel="self" type="application/atom+xml" />
  <link href="/" rel="alternate" type="text/html" />
  <updated>2021-01-09T19:16:07+09:00</updated>
  <id>/author/ardo/feed.xml</id>

  
  
  

  
    <title type="html">ArdoDulcis | </title>
  

  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">자식 컴포넌트를 쓰는 방식들</title>
      <link href="/using-react-component" rel="alternate" type="text/html" title="자식 컴포넌트를 쓰는 방식들" />
      <published>2021-01-09T09:00:00+09:00</published>
      <updated>2021-01-09T09:00:00+09:00</updated>
      <id>/using-react-component</id>
      <content type="html" xml:base="/using-react-component">&lt;p&gt;작년부터 React로 SPA개발하면서 자식 컴포넌트를 쓰는방식에 대해 의문점이 들었다. 자식 컴포넌트를 컴포넌트 내부에서 선언하고 바로 가져다 쓰는 방식과 컴포넌트 외부에서 자식 컴포넌트를 선언하거나 끌어다 쓰는 방식에 대한 것이었다. 분명히 차이가 있는데 대체 무슨 차이가 있는지 어떤 상황에서 쓰면 좋을지 잘 몰라서 열심히 구글링 해보았지만 이렇다할 글이 없었다. 끝내 필자의 마음속의 &lt;a href=&quot;https://blog.shiren.dev/&quot;&gt;멘토&lt;/a&gt;이신 분께 따로 여쭈어보고 그 조언을 바탕으로 내 나름대로 이렇게 쓰면 좋겠다 라는게 확립되어서 공유해보고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;자식-컴포넌트-child-component&quot;&gt;자식 컴포넌트 (Child Component)?&lt;/h2&gt;

&lt;p&gt;거창하게 자식 컴포넌트라고 써놓긴 했는데 진짜 별거없다. 그냥 메인이 되는 부모컴포넌트에서 렌더링시에 끌어다가 쓰는 컴포넌트라 보면 되겠다. 컴포넌트의 상하관계를 설명하기 위해서 쓰는 용어인거 같다. (아직 주니어 개발자라 솔직히 이 이상 정확하게 설명하기 어렵다 흑흑…)&lt;/p&gt;

&lt;h2 id=&quot;자식-컴포넌트를-쓰는-방식들&quot;&gt;자식 컴포넌트를 쓰는 방식들&lt;/h2&gt;

&lt;p&gt;React에서 컴포넌트를 끌어다 쓰는 방식은 필자의 지식 선에선 3가지 방법이 있다. 첫째 이미 만들어진 다른 컴포넌트를 import하여 끌어다 쓰는 방식. 둘째 메인 컴포넌트 (즉 부모가 되는 컴포넌트) 스코프 밖에서 다른 컴포넌트를 선언하여 끌어다 쓰는 방식. 마지막으로 컴포넌트 내부 스코프에서 컴포넌트를 선언하여 쓰는 방식. 이 3가지가 있다. 예제 코드를 보면서 차이점을 보자. (예제 코드는 최근 React의 대세라고 생각하는 React hook을 이용한 함수형 컴포넌트를 기반으로 썼다.)&lt;/p&gt;

&lt;h3 id=&quot;컴포넌트를-import하는-경우&quot;&gt;컴포넌트를 import하는 경우&lt;/h3&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// ./Components/AnyChild.tsx&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;react&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AnyChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;childState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;childState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;childState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AnyChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// ./Components/Parent.tsx&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;useState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;react&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AnyChild&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;./Components/AnyChild.tsx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parentState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setParentState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;AnyChild&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;childState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parentState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 방식은 &lt;code class=&quot;highlighter-rouge&quot;&gt;AnyChild&lt;/code&gt;라는 컴포넌트를 import하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;childState&lt;/code&gt;라는 props로 데이터를 할당하고 있다. 이 props는 stateless컴포넌트일 경우 없을수도 있다. 비교를 위해 stateful 컴포넌트라는 전제 조건으로 작성한 코드다. stateless 컴포넌트와 stateful 컴포넌트에 대한 것은 추후 다른 포스트에서 설명하도록 하겠다.&lt;/p&gt;

&lt;h3 id=&quot;컴포넌트-외부-스코프에서-선언하여-쓰는-경우&quot;&gt;컴포넌트 외부 스코프에서 선언하여 쓰는 경우&lt;/h3&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;useState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;react&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AnyChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;childState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;childState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;childState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parentState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setParentState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;AnyChild&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;childState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parentState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 방식은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Parent&lt;/code&gt;라는 컴포넌트의 외부 스코프에 &lt;code class=&quot;highlighter-rouge&quot;&gt;AnyChild&lt;/code&gt;라는 컴포넌트를 만들어 참조하여 쓰는 방식이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;childState&lt;/code&gt;라는 props로 데이터를 받아와서 렌더링하고 있다. 컴포넌트의 외부 스코프에서 직접 컴포넌트를 선언하여 쓰는 것 외에는 import하여 쓰는방식과 별반 차이가 없다.&lt;/p&gt;

&lt;h3 id=&quot;컴포넌트-내부-스코프에서-선언하여-쓰는-경우&quot;&gt;컴포넌트 내부 스코프에서 선언하여 쓰는 경우&lt;/h3&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;useState&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;react&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parentState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setParentState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;useState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;AnyChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;React&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;FC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parentState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/div&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;
&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;AnyChild&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 방식은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Parent&lt;/code&gt;라는 컴포넌트의 내부 스코프에 &lt;code class=&quot;highlighter-rouge&quot;&gt;AnyChild&lt;/code&gt;라는 컴포넌트를 만들고 &lt;code class=&quot;highlighter-rouge&quot;&gt;AnyChild&lt;/code&gt;컴포넌트에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Parent&lt;/code&gt;컴포넌트의 상태변수를 직접적으로 참조하고 있다. props로 데이터를 넘겨서 렌더링하는 위의 두 방식과는 확연히 차이가 난다.&lt;/p&gt;

&lt;h2 id=&quot;개인적인-견해&quot;&gt;개인적인 견해&lt;/h2&gt;

&lt;p&gt;결론부터 말하자면 컴포넌트의 목적과 성격에 맞게 쓰면 된다고 말하고 싶다.&lt;/p&gt;

&lt;h3 id=&quot;첫째-import하여-컴포넌트를-끌어다-쓰는-방식&quot;&gt;첫째. import하여 컴포넌트를 끌어다 쓰는 방식&lt;/h3&gt;

&lt;p&gt;이 경우 재사용의 가능성이 높은 컴포넌트를 끌어다 쓸때 쓰면 좋을 것 같다. 딱히 다른 컴포넌트에서 import할 필요도 없는 재사용의 가능성이 0인 컴포넌트인데 별개의 파일로 만들어서 import하여 쓸경우 괜히 파일만 늘어나는 꼴이 된다.&lt;/p&gt;

&lt;h3 id=&quot;둘째-컴포넌트의-스코프-외부에서-선언하여-참조하여-쓰는-경우&quot;&gt;둘째. 컴포넌트의 스코프 외부에서 선언하여 참조하여 쓰는 경우&lt;/h3&gt;

&lt;p&gt;이 경우 재사용 가능성이 0지만 부모컴포넌트와 밀접한 관련이 있고 비즈니스 로직이 복잡하여 로직을 확연하게 구분할 필요성이 있을 경우 쓰면 좋을 것같다. 예를 들어 데이터가 부모컴포넌트에 의존하고 그 데이터를 기반으로 연산을 한다던지 input요소의 데이터가 부모컴포넌트의 데이터와 밀접한 관련이 있는데 데이터 조작을 위해 자식 컴포넌트의 상태만 갱신할 필요성이 있다던지 말이다. (이 부분은 최적화에도 연관이 있을것 같다.)&lt;/p&gt;

&lt;h3 id=&quot;마지막-컴포넌트-내부-스코프에-컴포넌트를-선언하여-쓰는-경우&quot;&gt;마지막. 컴포넌트 내부 스코프에 컴포넌트를 선언하여 쓰는 경우&lt;/h3&gt;

&lt;p&gt;이경우 재사용 가능성도 0, 부모컴포넌트의 데이터를 기반으로 보여주기만 하는 컴포넌트일 경우 쓰면 좋을 것 같다. 데이터를 조작할 필요도 없는데 props를 이용하여 데이터를 넘기는 건 너무 돌려 쓰는것 같고 해당 컴포넌트가 어디에 있는가도 확인해야 하며 개발자에게 “아 이 컴포넌트에서 무언갈 하고있구나” 라는 인식을 심어주고 확인했더니 아무것도 안하고 있으면 괜한 시간만 쓴 격이 되어 유지 보수 측면에서 안좋을 수도 있다. 물론 세번째 방식은 부모컴포넌트의 상태가 갱신될 경우 함수(컴포넌트)가 새롭게 정의 되니 메모리 관리 측면에서 안좋을 수도 있다. 하지만 스코프 체인을 통해 부모컴포넌트의 상태를 직접 참조 할수있고 자원을 공유할수있는 장점이 있고 파일안에서 코드를 파악하기 쉽다.&lt;/p&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;

&lt;p&gt;컴포넌트를 선언하고 끌어다 쓰는 방식은 여러가지가 있다. 솔직히 그냥 막 쓰면 된다. 그러나 자고로 개발자란 항상 설계를 염두에 두고 개발해야한다고 생각한다. 염두에 안두고 대충 막쓰면 나중에 프로젝트가 커지거나 코드 전체를 리팩토링해야 될 경우가 오면 설계를 염두에 안두고 막 쓴 자신이 정말 미워지기 시작한다. (필자도 이 github page로 블로그를 이전하기전에 next.js 기반으로 만든 블로그가 있는데 설계도 안하고 대충 막 개발했다가 리팩토링 하면서 엄청 후회한 경험이 있다. 결국 포기하고 github page로 도망왔다 ㅋㅋ)
그렇기에 컴포넌트를 만들거나 쓸때 어떤 상황에 써야 적합할지 어떻게 개발을 하면 좋을지 혹은 지금도 React로 개발을하면서 왜 이렇게 쓰는거지? 라는 고민을 고민을 가진 개발자분들께 도움이 되길 바라며 글을 마친다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Ardo</name>
        
        
      </author>

      

      
        <category term="posts" />
      
        <category term="React" />
      
        <category term="FrontEnd" />
      

      
        <summary type="html">작년부터 React로 SPA개발하면서 자식 컴포넌트를 쓰는방식에 대해 의문점이 들었다. 자식 컴포넌트를 컴포넌트 내부에서 선언하고 바로 가져다 쓰는 방식과 컴포넌트 외부에서 자식 컴포넌트를 선언하거나 끌어다 쓰는 방식에 대한 것이었다. 분명히 차이가 있는데 대체 무슨 차이가 있는지 어떤 상황에서 쓰면 좋을지 잘 몰라서 열심히 구글링 해보았지만 이렇다할 글이 없었다. 끝내 필자의 마음속의 멘토이신 분께 따로 여쭈어보고 그 조언을 바탕으로 내 나름대로 이렇게 쓰면 좋겠다 라는게 확립되어서 공유해보고자 한다. 자식 컴포넌트 (Child Component)? 거창하게 자식 컴포넌트라고 써놓긴 했는데 진짜 별거없다. 그냥 메인이 되는 부모컴포넌트에서 렌더링시에 끌어다가 쓰는 컴포넌트라 보면 되겠다. 컴포넌트의 상하관계를 설명하기 위해서 쓰는 용어인거 같다. (아직 주니어 개발자라 솔직히 이 이상 정확하게 설명하기 어렵다 흑흑…) 자식 컴포넌트를 쓰는 방식들 React에서 컴포넌트를 끌어다 쓰는 방식은 필자의 지식 선에선 3가지 방법이 있다. 첫째 이미 만들어진 다른 컴포넌트를 import하여 끌어다 쓰는 방식. 둘째 메인 컴포넌트 (즉 부모가 되는 컴포넌트) 스코프 밖에서 다른 컴포넌트를 선언하여 끌어다 쓰는 방식. 마지막으로 컴포넌트 내부 스코프에서 컴포넌트를 선언하여 쓰는 방식. 이 3가지가 있다. 예제 코드를 보면서 차이점을 보자. (예제 코드는 최근 React의 대세라고 생각하는 React hook을 이용한 함수형 컴포넌트를 기반으로 썼다.) 컴포넌트를 import하는 경우 // ./Components/AnyChild.tsx import React from &quot;react&quot;; const AnyChild: React.FC&amp;lt;{ childState: string, }&amp;gt; = ({ childState }) =&amp;gt; &amp;lt;div&amp;gt;{childState}&amp;lt;/div&amp;gt;; export default AnyChild; // ./Components/Parent.tsx import React, { useState } from &quot;react&quot;; import AnyChild from &quot;./Components/AnyChild.tsx&quot;; const Parent: React.FC = () =&amp;gt; { const [parentState, setParentState] = useState(&quot;&quot;); return &amp;lt;AnyChild childState={parentState} /&amp;gt;; }; 위의 방식은 AnyChild라는 컴포넌트를 import하여 childState라는 props로 데이터를 할당하고 있다. 이 props는 stateless컴포넌트일 경우 없을수도 있다. 비교를 위해 stateful 컴포넌트라는 전제 조건으로 작성한 코드다. stateless 컴포넌트와 stateful 컴포넌트에 대한 것은 추후 다른 포스트에서 설명하도록 하겠다. 컴포넌트 외부 스코프에서 선언하여 쓰는 경우 import React, { useState } from &quot;react&quot;; const AnyChild: React.FC&amp;lt;{ childState: string, }&amp;gt; = ({ childState }) =&amp;gt; &amp;lt;div&amp;gt;{childState}&amp;lt;/div&amp;gt;; const Parent: React.FC = () =&amp;gt; { const [parentState, setParentState] = useState(&quot;&quot;); return &amp;lt;AnyChild childState={parentState} /&amp;gt;; }; 위의 방식은 Parent라는 컴포넌트의 외부 스코프에 AnyChild라는 컴포넌트를 만들어 참조하여 쓰는 방식이다. childState라는 props로 데이터를 받아와서 렌더링하고 있다. 컴포넌트의 외부 스코프에서 직접 컴포넌트를 선언하여 쓰는 것 외에는 import하여 쓰는방식과 별반 차이가 없다. 컴포넌트 내부 스코프에서 선언하여 쓰는 경우 import React, { useState } from &quot;react&quot;; const Parent: React.FC = () =&amp;gt; { const [parentState, setParentState] = useState(&quot;&quot;); const AnyChild: React.FC = () =&amp;gt; &amp;lt;div&amp;gt;{parentState}&amp;lt;/div&amp;gt;; return &amp;lt;AnyChild /&amp;gt;; }; 위의 방식은 Parent라는 컴포넌트의 내부 스코프에 AnyChild라는 컴포넌트를 만들고 AnyChild컴포넌트에서 Parent컴포넌트의 상태변수를 직접적으로 참조하고 있다. props로 데이터를 넘겨서 렌더링하는 위의 두 방식과는 확연히 차이가 난다. 개인적인 견해 결론부터 말하자면 컴포넌트의 목적과 성격에 맞게 쓰면 된다고 말하고 싶다. 첫째. import하여 컴포넌트를 끌어다 쓰는 방식 이 경우 재사용의 가능성이 높은 컴포넌트를 끌어다 쓸때 쓰면 좋을 것 같다. 딱히 다른 컴포넌트에서 import할 필요도 없는 재사용의 가능성이 0인 컴포넌트인데 별개의 파일로 만들어서 import하여 쓸경우 괜히 파일만 늘어나는 꼴이 된다. 둘째. 컴포넌트의 스코프 외부에서 선언하여 참조하여 쓰는 경우 이 경우 재사용 가능성이 0지만 부모컴포넌트와 밀접한 관련이 있고 비즈니스 로직이 복잡하여 로직을 확연하게 구분할 필요성이 있을 경우 쓰면 좋을 것같다. 예를 들어 데이터가 부모컴포넌트에 의존하고 그 데이터를 기반으로 연산을 한다던지 input요소의 데이터가 부모컴포넌트의 데이터와 밀접한 관련이 있는데 데이터 조작을 위해 자식 컴포넌트의 상태만 갱신할 필요성이 있다던지 말이다. (이 부분은 최적화에도 연관이 있을것 같다.) 마지막. 컴포넌트 내부 스코프에 컴포넌트를 선언하여 쓰는 경우 이경우 재사용 가능성도 0, 부모컴포넌트의 데이터를 기반으로 보여주기만 하는 컴포넌트일 경우 쓰면 좋을 것 같다. 데이터를 조작할 필요도 없는데 props를 이용하여 데이터를 넘기는 건 너무 돌려 쓰는것 같고 해당 컴포넌트가 어디에 있는가도 확인해야 하며 개발자에게 “아 이 컴포넌트에서 무언갈 하고있구나” 라는 인식을 심어주고 확인했더니 아무것도 안하고 있으면 괜한 시간만 쓴 격이 되어 유지 보수 측면에서 안좋을 수도 있다. 물론 세번째 방식은 부모컴포넌트의 상태가 갱신될 경우 함수(컴포넌트)가 새롭게 정의 되니 메모리 관리 측면에서 안좋을 수도 있다. 하지만 스코프 체인을 통해 부모컴포넌트의 상태를 직접 참조 할수있고 자원을 공유할수있는 장점이 있고 파일안에서 코드를 파악하기 쉽다. 마치며 컴포넌트를 선언하고 끌어다 쓰는 방식은 여러가지가 있다. 솔직히 그냥 막 쓰면 된다. 그러나 자고로 개발자란 항상 설계를 염두에 두고 개발해야한다고 생각한다. 염두에 안두고 대충 막쓰면 나중에 프로젝트가 커지거나 코드 전체를 리팩토링해야 될 경우가 오면 설계를 염두에 안두고 막 쓴 자신이 정말 미워지기 시작한다. (필자도 이 github page로 블로그를 이전하기전에 next.js 기반으로 만든 블로그가 있는데 설계도 안하고 대충 막 개발했다가 리팩토링 하면서 엄청 후회한 경험이 있다. 결국 포기하고 github page로 도망왔다 ㅋㅋ) 그렇기에 컴포넌트를 만들거나 쓸때 어떤 상황에 써야 적합할지 어떻게 개발을 하면 좋을지 혹은 지금도 React로 개발을하면서 왜 이렇게 쓰는거지? 라는 고민을 고민을 가진 개발자분들께 도움이 되길 바라며 글을 마친다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">가상 DOM</title>
      <link href="/virtualDOM" rel="alternate" type="text/html" title="가상 DOM" />
      <published>2020-12-05T21:00:00+09:00</published>
      <updated>2020-12-05T21:00:00+09:00</updated>
      <id>/virtualDOM</id>
      <content type="html" xml:base="/virtualDOM">&lt;h2 id=&quot;virtualdom-가상-dom에-대해-알고계신가요&quot;&gt;VirtualDOM (가상 DOM)에 대해 알고계신가요?&lt;/h2&gt;

&lt;p&gt;2년전 프론트엔드 기술 중에 어떤 기술들이 유행하고있는지 알아보다가 접한 React. 처음엔 기존의 JavaScript와는 틀린 독특한 문법때문에 막연히 배우기 시작한 React.
최근 실무에서 React를 이용해서 웹 어플리케이션을 개발하는 일이 잦아졌다. 그래서 그런지 문득 React란 무엇이고 어떤 장점을 가졌고 어떤 기술들을 기반으로 개발되었는지 등등 기본적인 것들을 제대로 이해하고 쓰고있는 것인지 의문이 들었다.&lt;/p&gt;

&lt;p&gt;단방향 데이터 바인딩, 컴포넌트를 기준으로 한 프로젝트 구성, Virtual DOM등등 여러 장점이 있다는건 알고있다.&lt;/p&gt;

&lt;p&gt;그 중 SPA개발에 특화되어있는 라이브러리 React나 프레임워크인 Vue을 보면 Virtual DOM이라는 개념을 자세하게 설명이 가능한지 내 자신에게 물어보았다. 그러나 음…?? 전반적인 개념은 알겠는데 대체 무슨 장점이 있고 구체적으로 어떤 일을 하는건지 결국 대답을 못하고 있었다.&lt;/p&gt;

&lt;p&gt;그런도중 여러 기술 블로그를 본 결과 정말 이해가 잘 가도록 정리된 글을 보아 공유하고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;왜-virtualdom-가상-dom을-쓰는건데요&quot;&gt;왜 VirtualDOM (가상 DOM)을 쓰는건데요?&lt;/h2&gt;

&lt;p&gt;참고한 블로그 글에 이런 기술이 있었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The other day a friend had this React question for me: “Composition through components, one way data binding; I understand all that, but why Virtual DOM?”.
I’ve given him the usual answer. “Because, direct DOM manipulation is inefficient, and slow.”
“There’s always news on how JavaScript engines are getting performant; what makes adding something directly to the DOM slow?”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://hashnode.com/post/the-one-thing-that-no-one-properly-explains-about-react-why-virtual-dom-cisczhfj41bmssp53mvfwmgrq&quot;&gt;블로그 원문&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;내용은 어느 날 친구가 React의 장점에 대해서는 알겠는데 왜 Virtual DOM인지 질문하는 장면이다. 질문을 받은 친구는 직접적인 DOM 조작은 비효율적이며 또한 느리기때문이라고 설명한다. 그러나 답변을 받은 친구는 최근의 JavaScript는 퍼포먼스적으로도 빨라지고 있는데 대체 무엇때문에 직접적인 DOM조작이 느려지는 원인인건지 모르겠다는 것이다.&lt;/p&gt;

&lt;p&gt;이 대화내용을 보고 나 또한 2년전쯤엔가 읽었던 하나의 블로그 글이 떠올랐다. 직접적인 DOM조작을 기반으로 하는 jQuery의 한계. 그리고 등장한 새로운 패러다임 React와 Vue, Anguler. 그 당시에는 아 그냥 유행이 그런가보다 하고 이해해버린 글이었다.&lt;/p&gt;

&lt;p&gt;JavaScript 엔진 자체는 나날히 발전을 거듭하면서 퍼포먼스적으로도 지속해서 개선되어 지고있다. 그러나 거진 10년이란 세월을 80%이상의 사이트가 jQuery를 이용할 정도로 많은 개발자들이 써왔던 jQuery. 그것을 최근 React들이 대체하기 시작했다.&lt;/p&gt;

&lt;p&gt;왜일까? 그 이유는 직접적인 DOM조작후에 일어나는 일에 있다고 한다.&lt;/p&gt;

&lt;h3 id=&quot;브라우저에서-일어나는-일들&quot;&gt;브라우저에서 일어나는 일들&lt;/h3&gt;

&lt;p&gt;간략하게 브라우저에서 일어나는 일들을 나열해보자면 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTML Parse&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;서버에서 받아온 HTML소스를 파싱한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DOM Tree 생성&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;파싱한 HTML소스를 기반으로 DOM Tree (Node)를 작성한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Render Tree 생성&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;작성된 DOM Tree에 스타일을 입히고 Render Tree를 작성한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Layout or Reflow (각 노드의 표시 장소 결정)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;작성된 Render Tree를 가지고 각 노드 (엘리먼트 or 요소라고도 불립니다.)를 어디에 배치할지 계산.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Painting (브라우저에 표시)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;마지막단계로서 Layout단계에서 각 노드가 어디에 배치되야 될지 계산이 끝나면 색을 입히면서 브라우저에 그리기 시작. 이때 유저에게 컨텐츠가 표시되기 시작한다.
아래 그림을 참고하면 이해하기 쉬울 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/images/renderDom.png&quot; alt=&quot;브라우저의 페이지가 유저에게 보여지기 까지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이미지 출처: &lt;a href=&quot;https://hacks.mozilla.org/2017/08/inside-a-super-fast-css-engine-quantum-css-aka-stylo/&quot;&gt;모질라 HACKS&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;직접적인-dom-조작-무엇이-문제인가&quot;&gt;직접적인 DOM 조작 무엇이 문제인가&lt;/h3&gt;

&lt;p&gt;대략적으로 브라우저에서 일어나는 일들을 알아보았다. 그렇다면 대체 무엇이 직접적인 DOM 조작을 하면 성능상 문제가 생기는걸까?&lt;/p&gt;

&lt;p&gt;결론부터 말하자면 상황에 따라서 문제가 생긴다. 브라우저는 JavaScript로 인하여 DOM Tree나 요소의 CSS속성이 변경될 경우 레이아웃 (리플로우라고도 불린다.) 과정을 거친다. 이 과정에서 브라우저는 적용할 DOM Tree를 재구성 및 각 노드들의 배치를 재결정하기 위해 계산을 한다. 이게 어느정도 DOM을 조작한다던가 하면 그렇게 문제될 상황은 아닐것이다. 그러나 SPA (Single Page Application)의 경우는 전혀 그렇지 않다. 사용자에게 더욱 빠르게 반응하기 위해서 기존의 SSR (Server Side Rendering)에서 CSR (Client Side Rendering)를 기본이고 렌더링 방법으로 사용하며 CSR은 SSR과는 다르게 웹페이지를 사용자가 원하는 컨텐츠를 보여주기 위해 서버에 새로운 HTML정보를 요청하지 않고 &lt;strong&gt;그 자리에서&lt;/strong&gt; DOM구조를 바꾸어서 보여준다.&lt;/p&gt;

&lt;p&gt;여기서 문제가 생긴다. DOM구조를 바꾼다는 것은 결국 리플로우를 발생시킨다는 것이다. 이것이 SPA에선 자주 발생한다. 만약 20번의 구조에 변화가 생긴다면 어떨까?? 브라우저는 뒤에서 20번의 연산을 하게 된다. 사용자에게 빠르게 반응하기 위한 SPA에 있어서 이보다 나쁜소식은 없다.&lt;/p&gt;

&lt;h3 id=&quot;virtual-dom은-뭐가-좋은가&quot;&gt;Virtual DOM은 뭐가 좋은가&lt;/h3&gt;

&lt;p&gt;다시 본론으로 돌아와서 가상DOM을 쓰면 어느 부분에서 좋은지 알아보자. 가상DOM은 2가지를 해결하기 위해 생겼다고 한다. 이 설명은 원문 기사에 있는 어느 Reddit 유저분이 정리해주신 걸 참고하겠다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가상DOM을 이용해 변화된 부분만 감지, 여러 변화를 하나로 묶어서 연산하고 실제 DOM에 넘겨준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;The real problem with DOM manipulation is that each manipulation can trigger layout changes, tree modifications and rendering. Each of them. So, say you modified 30 nodes, one by one. That would mean 30 (potential) re-calculations of the layout, 30 (potential) re-renderings, etc.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;DOM조작의 진짜 문제는 조작으로 인한 레이아웃과 DOM 트리의 변화에 있습니다. 이 변화로 인해 렌더링을 일으키구요. 만약 여러분들이 30개의 노드를 하나하나 변경했다고 합시다. 이것은 30번(잠재적인)의 재계산과 레이아웃 (리플로우), 30번(잠재적인)의 리렌더링을 일으킨다는 것을 의미합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 Reddit유저분이 정리해준것과 같이 DOM의 직접적인 조작의 문제는 DOM트리의 변화에 있다. 이 변화가 재계산, 레이아웃, 리렌더링을 초래한다는것이다. 이 변화를 렌더링되지 않는 가상 DOM에서 처리하고 최종적인 결과를 DOM에 전달하는것으로 1번만 리렌더링을 하는것으로 연산비용을 최소화 시켜준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DOM fragment를 관리하는 과정을 자동화 추상화 하기 위함이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 해결방법은 굳이 가상DOM을 쓰지않아도 DOM fragment를 이용해서 그 변화를 묶어서 DOM에게 최종적인 결과만 전달해주면 된다고 한다. 하지만 이러한 방식은 프론트엔드 개발자가 상황을 지속적으로 파악하고 있어야 되며 개발하는데 있어 코스트를 높일 뿐이다. 이것을 가상DOM에서 자동화하고 추상화하여 개발 코스트를 낮출수 있던것이 아닐까??&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;But actually, this particular behaviour can be achieved without a virtual DOM. You can manually group all the DOM modifications in a DOM fragment yourself and then dump it into the DOM.
So, again, what does a Virtual DOM solve? It automates and abstracts the management of that DOM fragment so you don’t have to do it manually. Not only that, but when doing it manually you have to keep track of which parts have changed and which ones haven’t (because if you don’t you’d end up refreshing huge pieces of the DOM tree that may not need to be refreshed). So a Virtual DOM (if implemented correctly) also automates this for you, knowing which parts need to be refreshed and which parts don’t.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;솔직히 이러한 해결방법은 굳이 가상DOM이 아니어도 해결할수 있습니다. 변화가 있을때 DOM fragment를 이용해 그 변화를 묶어서 DOM에게 넘겨주면 그만이니까요.
그러면 정말 가상DOM에서 무엇을 해결하려고 한걸까요? 그것은 DOM fragment를 자동화하고 추상화하여 일일히 관리하지 않기 위해서에요. 만약 이 과정을 일일히 관리한다고 하면 여러분들이 어떤 값들이 변경되었고 어떤 값들이 변경되지 않았는지 변화를 파악하고 관리해줘야합니다 (안 그러면 갱신할 필요도 없는 DOM트리를 갱신해버릴수도 있어요.).하지만 가상DOM(올바르게 구현 된 경우)은 이것들을 여러분 대신에 자동으로 관리해줍니다. 어떤 것이 갱신이 필요한지 알려주죠.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;끝으로&quot;&gt;끝으로&lt;/h2&gt;

&lt;p&gt;지금까지 가상DOM이 어떤 부분이 좋고 무엇을 해결하기 위해 태어났는지 알아보았다. 필자 또한 이 공유를 통해 꼭 React나 Vue, Angular를 쓰는것이 좋은 것만이 아니구나라고 느꼈다. 만드는 웹페이지, 어플리케이션에 목적에 따라 jQuery를 쓸수도 있는것이고 React를 쓸수도 있다.
이 포스트를 읽은 모든 개발자분들이 가상DOM에 대해 한층 깊게 이해되는 계기가 되길 빌며 마친다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Ardo</name>
        
        
      </author>

      

      
        <category term="posts" />
      
        <category term="WebApplication" />
      
        <category term="FrontEnd" />
      
        <category term="tech" />
      

      
        <summary type="html">VirtualDOM (가상 DOM)에 대해 알고계신가요? 2년전 프론트엔드 기술 중에 어떤 기술들이 유행하고있는지 알아보다가 접한 React. 처음엔 기존의 JavaScript와는 틀린 독특한 문법때문에 막연히 배우기 시작한 React. 최근 실무에서 React를 이용해서 웹 어플리케이션을 개발하는 일이 잦아졌다. 그래서 그런지 문득 React란 무엇이고 어떤 장점을 가졌고 어떤 기술들을 기반으로 개발되었는지 등등 기본적인 것들을 제대로 이해하고 쓰고있는 것인지 의문이 들었다. 단방향 데이터 바인딩, 컴포넌트를 기준으로 한 프로젝트 구성, Virtual DOM등등 여러 장점이 있다는건 알고있다. 그 중 SPA개발에 특화되어있는 라이브러리 React나 프레임워크인 Vue을 보면 Virtual DOM이라는 개념을 자세하게 설명이 가능한지 내 자신에게 물어보았다. 그러나 음…?? 전반적인 개념은 알겠는데 대체 무슨 장점이 있고 구체적으로 어떤 일을 하는건지 결국 대답을 못하고 있었다. 그런도중 여러 기술 블로그를 본 결과 정말 이해가 잘 가도록 정리된 글을 보아 공유하고자 한다. 왜 VirtualDOM (가상 DOM)을 쓰는건데요? 참고한 블로그 글에 이런 기술이 있었다. The other day a friend had this React question for me: “Composition through components, one way data binding; I understand all that, but why Virtual DOM?”. I’ve given him the usual answer. “Because, direct DOM manipulation is inefficient, and slow.” “There’s always news on how JavaScript engines are getting performant; what makes adding something directly to the DOM slow?” 블로그 원문 내용은 어느 날 친구가 React의 장점에 대해서는 알겠는데 왜 Virtual DOM인지 질문하는 장면이다. 질문을 받은 친구는 직접적인 DOM 조작은 비효율적이며 또한 느리기때문이라고 설명한다. 그러나 답변을 받은 친구는 최근의 JavaScript는 퍼포먼스적으로도 빨라지고 있는데 대체 무엇때문에 직접적인 DOM조작이 느려지는 원인인건지 모르겠다는 것이다. 이 대화내용을 보고 나 또한 2년전쯤엔가 읽었던 하나의 블로그 글이 떠올랐다. 직접적인 DOM조작을 기반으로 하는 jQuery의 한계. 그리고 등장한 새로운 패러다임 React와 Vue, Anguler. 그 당시에는 아 그냥 유행이 그런가보다 하고 이해해버린 글이었다. JavaScript 엔진 자체는 나날히 발전을 거듭하면서 퍼포먼스적으로도 지속해서 개선되어 지고있다. 그러나 거진 10년이란 세월을 80%이상의 사이트가 jQuery를 이용할 정도로 많은 개발자들이 써왔던 jQuery. 그것을 최근 React들이 대체하기 시작했다. 왜일까? 그 이유는 직접적인 DOM조작후에 일어나는 일에 있다고 한다. 브라우저에서 일어나는 일들 간략하게 브라우저에서 일어나는 일들을 나열해보자면 다음과 같다. HTML Parse 서버에서 받아온 HTML소스를 파싱한다. DOM Tree 생성 파싱한 HTML소스를 기반으로 DOM Tree (Node)를 작성한다. Render Tree 생성 작성된 DOM Tree에 스타일을 입히고 Render Tree를 작성한다. Layout or Reflow (각 노드의 표시 장소 결정) 작성된 Render Tree를 가지고 각 노드 (엘리먼트 or 요소라고도 불립니다.)를 어디에 배치할지 계산. Painting (브라우저에 표시) 마지막단계로서 Layout단계에서 각 노드가 어디에 배치되야 될지 계산이 끝나면 색을 입히면서 브라우저에 그리기 시작. 이때 유저에게 컨텐츠가 표시되기 시작한다. 아래 그림을 참고하면 이해하기 쉬울 것 같다. 이미지 출처: 모질라 HACKS 직접적인 DOM 조작 무엇이 문제인가 대략적으로 브라우저에서 일어나는 일들을 알아보았다. 그렇다면 대체 무엇이 직접적인 DOM 조작을 하면 성능상 문제가 생기는걸까? 결론부터 말하자면 상황에 따라서 문제가 생긴다. 브라우저는 JavaScript로 인하여 DOM Tree나 요소의 CSS속성이 변경될 경우 레이아웃 (리플로우라고도 불린다.) 과정을 거친다. 이 과정에서 브라우저는 적용할 DOM Tree를 재구성 및 각 노드들의 배치를 재결정하기 위해 계산을 한다. 이게 어느정도 DOM을 조작한다던가 하면 그렇게 문제될 상황은 아닐것이다. 그러나 SPA (Single Page Application)의 경우는 전혀 그렇지 않다. 사용자에게 더욱 빠르게 반응하기 위해서 기존의 SSR (Server Side Rendering)에서 CSR (Client Side Rendering)를 기본이고 렌더링 방법으로 사용하며 CSR은 SSR과는 다르게 웹페이지를 사용자가 원하는 컨텐츠를 보여주기 위해 서버에 새로운 HTML정보를 요청하지 않고 그 자리에서 DOM구조를 바꾸어서 보여준다. 여기서 문제가 생긴다. DOM구조를 바꾼다는 것은 결국 리플로우를 발생시킨다는 것이다. 이것이 SPA에선 자주 발생한다. 만약 20번의 구조에 변화가 생긴다면 어떨까?? 브라우저는 뒤에서 20번의 연산을 하게 된다. 사용자에게 빠르게 반응하기 위한 SPA에 있어서 이보다 나쁜소식은 없다. Virtual DOM은 뭐가 좋은가 다시 본론으로 돌아와서 가상DOM을 쓰면 어느 부분에서 좋은지 알아보자. 가상DOM은 2가지를 해결하기 위해 생겼다고 한다. 이 설명은 원문 기사에 있는 어느 Reddit 유저분이 정리해주신 걸 참고하겠다. 가상DOM을 이용해 변화된 부분만 감지, 여러 변화를 하나로 묶어서 연산하고 실제 DOM에 넘겨준다. The real problem with DOM manipulation is that each manipulation can trigger layout changes, tree modifications and rendering. Each of them. So, say you modified 30 nodes, one by one. That would mean 30 (potential) re-calculations of the layout, 30 (potential) re-renderings, etc. DOM조작의 진짜 문제는 조작으로 인한 레이아웃과 DOM 트리의 변화에 있습니다. 이 변화로 인해 렌더링을 일으키구요. 만약 여러분들이 30개의 노드를 하나하나 변경했다고 합시다. 이것은 30번(잠재적인)의 재계산과 레이아웃 (리플로우), 30번(잠재적인)의 리렌더링을 일으킨다는 것을 의미합니다. 이 Reddit유저분이 정리해준것과 같이 DOM의 직접적인 조작의 문제는 DOM트리의 변화에 있다. 이 변화가 재계산, 레이아웃, 리렌더링을 초래한다는것이다. 이 변화를 렌더링되지 않는 가상 DOM에서 처리하고 최종적인 결과를 DOM에 전달하는것으로 1번만 리렌더링을 하는것으로 연산비용을 최소화 시켜준다. DOM fragment를 관리하는 과정을 자동화 추상화 하기 위함이다. 이러한 해결방법은 굳이 가상DOM을 쓰지않아도 DOM fragment를 이용해서 그 변화를 묶어서 DOM에게 최종적인 결과만 전달해주면 된다고 한다. 하지만 이러한 방식은 프론트엔드 개발자가 상황을 지속적으로 파악하고 있어야 되며 개발하는데 있어 코스트를 높일 뿐이다. 이것을 가상DOM에서 자동화하고 추상화하여 개발 코스트를 낮출수 있던것이 아닐까?? But actually, this particular behaviour can be achieved without a virtual DOM. You can manually group all the DOM modifications in a DOM fragment yourself and then dump it into the DOM. So, again, what does a Virtual DOM solve? It automates and abstracts the management of that DOM fragment so you don’t have to do it manually. Not only that, but when doing it manually you have to keep track of which parts have changed and which ones haven’t (because if you don’t you’d end up refreshing huge pieces of the DOM tree that may not need to be refreshed). So a Virtual DOM (if implemented correctly) also automates this for you, knowing which parts need to be refreshed and which parts don’t. 솔직히 이러한 해결방법은 굳이 가상DOM이 아니어도 해결할수 있습니다. 변화가 있을때 DOM fragment를 이용해 그 변화를 묶어서 DOM에게 넘겨주면 그만이니까요. 그러면 정말 가상DOM에서 무엇을 해결하려고 한걸까요? 그것은 DOM fragment를 자동화하고 추상화하여 일일히 관리하지 않기 위해서에요. 만약 이 과정을 일일히 관리한다고 하면 여러분들이 어떤 값들이 변경되었고 어떤 값들이 변경되지 않았는지 변화를 파악하고 관리해줘야합니다 (안 그러면 갱신할 필요도 없는 DOM트리를 갱신해버릴수도 있어요.).하지만 가상DOM(올바르게 구현 된 경우)은 이것들을 여러분 대신에 자동으로 관리해줍니다. 어떤 것이 갱신이 필요한지 알려주죠. 끝으로 지금까지 가상DOM이 어떤 부분이 좋고 무엇을 해결하기 위해 태어났는지 알아보았다. 필자 또한 이 공유를 통해 꼭 React나 Vue, Angular를 쓰는것이 좋은 것만이 아니구나라고 느꼈다. 만드는 웹페이지, 어플리케이션에 목적에 따라 jQuery를 쓸수도 있는것이고 React를 쓸수도 있다. 이 포스트를 읽은 모든 개발자분들이 가상DOM에 대해 한층 깊게 이해되는 계기가 되길 빌며 마친다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">var, let, const 대체 무슨 차이일까?</title>
      <link href="/let,const,var" rel="alternate" type="text/html" title="var, let, const 대체 무슨 차이일까?" />
      <published>2019-09-27T19:00:00+09:00</published>
      <updated>2019-09-27T19:00:00+09:00</updated>
      <id>/let,const,var</id>
      <content type="html" xml:base="/let,const,var">&lt;h2 id=&quot;서술하기에-앞서&quot;&gt;서술하기에 앞서.&lt;/h2&gt;

&lt;p&gt;앞서 먼저 말씀드립니다. 이 포스트는 var와 let, const에 어떤 차이가 있는지 정도만 알수있게끔 아주 가볍게 다룬 글입니다. var는 Function Scope다 let, const는 Block Scope다 뭐다 하는 설명은 싹다 생략 되어있습니다. 좀 더 깊은 지식을 위한 글이 아니며, JavaScript를 처음 배우시는 분들을 위해 궁금증을 해소하기 위한 정도의 글이오니 양해 부탁드립니다. Function Scope는 무엇인지, Block Scope는 무엇인지에 관한 것은 후에 다른 포스트에서 서술 할 예정입니다.&lt;/p&gt;

&lt;h2 id=&quot;var-let-const-대체-무슨-차이일까&quot;&gt;var, let, const 대체 무슨 차이일까?&lt;/h2&gt;

&lt;p&gt;ES6에 오면서 추가 된 변수 선언중에 let과 const가 있다. 대체 이놈들이 var로 선언해왔던 변수선언과 어떤 차이가 있을까? 이번 포스트에서는 var와 let, cosnt의 차이를 알아보고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;javascript를-배우면-가장-처음-접하는-선언법-var&quot;&gt;JavaScript를 배우면 가장 처음 접하는 선언법 var.&lt;/h2&gt;

&lt;p&gt;요즘에는 어떤지 잘 모르겠는데, ES6문법이 주된 문법이 되기전까진 JavaScript를 배우기 시작하면 가장 먼저 배우게 되는 변수 선언이다.
거창한 설명은 안하겠다. 선언법은 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hello world&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//a라는 상자에 hello world라는 문자를 집어넣음&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//콘솔창에 표시 hello world&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;let-const-이건-뭐지&quot;&gt;let?? const?? 이건 뭐지…&lt;/h2&gt;

&lt;p&gt;필자같은 경운 JavaScript를 어느정도 배우고 난뒤에 ES6라는 문법을 알게되었다.&lt;/p&gt;

&lt;p&gt;ES6의 변수 선언식. 즉 var로 선언하던 ES5문법이 진화(?)한 형태다. 일단 코드부터 보자.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hello world&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//a라는 상자에 hello world라는 문자를 집어넣음&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//b라는 상자에 1이라는 숫자를 집어넣음&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//콘솔창에 표시 결과는 hello world&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//콘솔창에 표시 결과는 1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;아니-같은-변수선언식이면-var로-선언하면-되잖아&quot;&gt;아니 같은 변수선언식이면 var로 선언하면 되잖아.&lt;/h2&gt;

&lt;p&gt;솔직히 필자도 처음에 봤을때 ‘아니 그냥 var로 선언하면 되잖아. 왜 굳이?’라고 생각했었다.&lt;/p&gt;

&lt;p&gt;하지만 우리가 누군가? 개발자다! 왜?라는 사고를 가진 사람들이다. 그래서 찾아봤다!
왜! let, const라는 놈이 탄생했는지! var가 뭐가 나쁜데!를 말이다.&lt;/p&gt;

&lt;h2 id=&quot;var-나쁜애-아니에요&quot;&gt;var 나쁜애 아니에요.&lt;/h2&gt;

&lt;p&gt;그렇다. var는 나쁜애가 아니다. 나쁘다고 한다면 언어자체가 엄청나게? 유연한 JavaScript가 나쁜놈이다. 다음 코드를 보자.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//결과는 undefined&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Dulcis&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// name이라는 상자안에 Dulcis라는 문자를 집어넣음&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//결과는 Dulcis&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;왜 나쁠까? 일반적으로 프로그래밍에선 변수선언을 안하고 바로 변수를 참조하려고 하면 그냥 바로 에러를 뱉는다. 근데 JavaScript라는 놈은 호이스팅이라는 현상으로 인해 에러를 안뱉는다!! 호이스팅이라는 이슈는 나중에 다른 포스팅에서 다루도록 하겠다. 호이스팅이란 간단하게 말하자면 변수선언전에 참조하려고 할 때 참조하려는 변수를 참조를 할 수 없어서 최상단으로 끌어올려서 선언해버리는 현상이다. 호이스팅 현상으로 인해 위의 같은 코드를 JavaScript에선 이렇게 해석한다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//name이라는 변수를 선언&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//결과는 undefined&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Dulcis&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//name이라는 상자안에 Dulcis라는 문자를 집어넣음&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//결과는 Dulcis&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;읭? 난 저렇게 코드 쓴적 없는데? &lt;code class=&quot;highlighter-rouge&quot;&gt;console.log(name)&lt;/code&gt;사이에 선언한 변수식이 제멋대로 위로 올라갔다. 황당하기 그지없다. 개발자가 쓴 코드대로 실행이 안되고 지멋대로 변수 선언을 위로 올리고 앉아있다.&lt;/p&gt;

&lt;h2 id=&quot;그래서-왔습니다-im-let-im-const&quot;&gt;그래서 왔습니다! I’m let! I’m const!&lt;/h2&gt;

&lt;h3 id=&quot;let의-특징&quot;&gt;let의 특징&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;와는 틀리게 재선언이 불가한 애다. 다음 코드를 보자.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;native&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//결과는 native&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mave&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//결과는 Uncaught SyntaxError: Identifier 'animalName' has already been declared.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드와 같이 재선언을 하려고 하면 너 문법 틀림. 하고 빨갛게 엄청 화내는 걸 볼 수 있다. 그럼 재할당은 어떨까??&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;native&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//결과는 native&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mave&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//결과는 mave&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;재선언은 안되지만 재할당은 아주 좋아하신다. &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;선언은 재선언은 불가능하지만 재할당은 가능한 걸 알 수 있다.&lt;/p&gt;

&lt;p&gt;다음은 &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;를 보자.&lt;/p&gt;

&lt;h3 id=&quot;const의-특징&quot;&gt;const의 특징&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;와는 틀리게 재선언도 안되고 재할당도 안된다. 그냥 “나 한번 먹으면 끝임.” 이러는 고집불통이다. 그래서 그런지 변수선언과 동시에 값을 부여 해주지 않으면 바로 에러를 내뱉어 주신다. 다음 코드를 보자.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//결과는 Uncaught SyntaxError: Missing initializer in const declaration.&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;native&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//결과는 native&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mave&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//결과는 Uncaught SyntaxError: Identifier 'animalName' has already been declared.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;과 똑같이 재선언을 못하고 에러를 내뱉는다. &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;도 그랬으니 여기까진 봐주자. 그렇다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;에서는 가능했던 재할당은 어떨까? 다음 코드를 보자.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;native&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//결과는 native&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mave&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;animalName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//결과는 Uncaught TypeError: Assignment to constant variable.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;한번 먹였으면 됬지 뭘 더 먹이려고 하냐면서 화를 내신다. 참 까탈스러운 분이다. 정리해보자면 &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;은 재선언은 불가능하지만 재할당은 가능하다. 그에 반해 &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;는 재할당도 안되고 재선언도 못한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;의 호이스팅 문제로 인하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;변수선언이 ES6에서 등장했다고 서술했다. 방금 전 호이스팅 현상을 &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;로 써보면 어떨까? 다음 코드에서는 한 눈으로 확인해보기 위하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; 둘 다 사용한 예제이다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;abcd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Uncaught ReferenceError: Cannot access 'name' before initialization.&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Yeah!!!!!!!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;bat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Uncaught ReferenceError: Cannot access 'animal' before initialization.&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;O.O&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;호이스팅이고 뭐고 다 필요없고 아주 멋지게 당장 에러를 내뱉어 주신다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;

&lt;p&gt;지금까지 ES5에서의 선언법 var와 ES6에서 새롭게 탑재된 선언법인 let과 const에 대해서 알아보았다.&lt;/p&gt;

&lt;p&gt;정리해보자면 var와 let, const의 차이점은 아래의 표와 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;선언문&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;재선언&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;재할당&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;가능&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;불가능&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;불가능&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;불가능&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content>

      
      
      
      
      

      <author>
          <name>Ardo</name>
        
        
      </author>

      

      
        <category term="posts" />
      
        <category term="JavaScript" />
      

      
        <summary type="html">서술하기에 앞서. 앞서 먼저 말씀드립니다. 이 포스트는 var와 let, const에 어떤 차이가 있는지 정도만 알수있게끔 아주 가볍게 다룬 글입니다. var는 Function Scope다 let, const는 Block Scope다 뭐다 하는 설명은 싹다 생략 되어있습니다. 좀 더 깊은 지식을 위한 글이 아니며, JavaScript를 처음 배우시는 분들을 위해 궁금증을 해소하기 위한 정도의 글이오니 양해 부탁드립니다. Function Scope는 무엇인지, Block Scope는 무엇인지에 관한 것은 후에 다른 포스트에서 서술 할 예정입니다. var, let, const 대체 무슨 차이일까? ES6에 오면서 추가 된 변수 선언중에 let과 const가 있다. 대체 이놈들이 var로 선언해왔던 변수선언과 어떤 차이가 있을까? 이번 포스트에서는 var와 let, cosnt의 차이를 알아보고자 한다. JavaScript를 배우면 가장 처음 접하는 선언법 var. 요즘에는 어떤지 잘 모르겠는데, ES6문법이 주된 문법이 되기전까진 JavaScript를 배우기 시작하면 가장 먼저 배우게 되는 변수 선언이다. 거창한 설명은 안하겠다. 선언법은 아래와 같다. var a = &quot;hello world&quot;; //a라는 상자에 hello world라는 문자를 집어넣음 console.log(a); //콘솔창에 표시 hello world let?? const?? 이건 뭐지… 필자같은 경운 JavaScript를 어느정도 배우고 난뒤에 ES6라는 문법을 알게되었다. ES6의 변수 선언식. 즉 var로 선언하던 ES5문법이 진화(?)한 형태다. 일단 코드부터 보자. let a = &quot;hello world&quot;; //a라는 상자에 hello world라는 문자를 집어넣음 const b = 1; //b라는 상자에 1이라는 숫자를 집어넣음 console.log(a); //콘솔창에 표시 결과는 hello world console.log(b); //콘솔창에 표시 결과는 1 아니 같은 변수선언식이면 var로 선언하면 되잖아. 솔직히 필자도 처음에 봤을때 ‘아니 그냥 var로 선언하면 되잖아. 왜 굳이?’라고 생각했었다. 하지만 우리가 누군가? 개발자다! 왜?라는 사고를 가진 사람들이다. 그래서 찾아봤다! 왜! let, const라는 놈이 탄생했는지! var가 뭐가 나쁜데!를 말이다. var 나쁜애 아니에요. 그렇다. var는 나쁜애가 아니다. 나쁘다고 한다면 언어자체가 엄청나게? 유연한 JavaScript가 나쁜놈이다. 다음 코드를 보자. console.log(name); //결과는 undefined var name = &quot;Dulcis&quot;; // name이라는 상자안에 Dulcis라는 문자를 집어넣음 console.log(name); //결과는 Dulcis 왜 나쁠까? 일반적으로 프로그래밍에선 변수선언을 안하고 바로 변수를 참조하려고 하면 그냥 바로 에러를 뱉는다. 근데 JavaScript라는 놈은 호이스팅이라는 현상으로 인해 에러를 안뱉는다!! 호이스팅이라는 이슈는 나중에 다른 포스팅에서 다루도록 하겠다. 호이스팅이란 간단하게 말하자면 변수선언전에 참조하려고 할 때 참조하려는 변수를 참조를 할 수 없어서 최상단으로 끌어올려서 선언해버리는 현상이다. 호이스팅 현상으로 인해 위의 같은 코드를 JavaScript에선 이렇게 해석한다. var name; //name이라는 변수를 선언 console.log(name); //결과는 undefined name = &quot;Dulcis&quot;; //name이라는 상자안에 Dulcis라는 문자를 집어넣음 console.log(name); //결과는 Dulcis 읭? 난 저렇게 코드 쓴적 없는데? console.log(name)사이에 선언한 변수식이 제멋대로 위로 올라갔다. 황당하기 그지없다. 개발자가 쓴 코드대로 실행이 안되고 지멋대로 변수 선언을 위로 올리고 앉아있다. 그래서 왔습니다! I’m let! I’m const! let의 특징 let은 var와는 틀리게 재선언이 불가한 애다. 다음 코드를 보자. let animalName = &quot;native&quot;; console.log(animalName); //결과는 native let animalName = &quot;mave&quot;; console.log(animalName); //결과는 Uncaught SyntaxError: Identifier 'animalName' has already been declared. 위의 코드와 같이 재선언을 하려고 하면 너 문법 틀림. 하고 빨갛게 엄청 화내는 걸 볼 수 있다. 그럼 재할당은 어떨까?? let animalName = &quot;native&quot;; console.log(animalName); //결과는 native animalName = &quot;mave&quot;; console.log(animalName); //결과는 mave 재선언은 안되지만 재할당은 아주 좋아하신다. let선언은 재선언은 불가능하지만 재할당은 가능한 걸 알 수 있다. 다음은 const를 보자. const의 특징 const는 let, var와는 틀리게 재선언도 안되고 재할당도 안된다. 그냥 “나 한번 먹으면 끝임.” 이러는 고집불통이다. 그래서 그런지 변수선언과 동시에 값을 부여 해주지 않으면 바로 에러를 내뱉어 주신다. 다음 코드를 보자. const animalName; //결과는 Uncaught SyntaxError: Missing initializer in const declaration. const animalName = &quot;native&quot;; console.log(animalName); //결과는 native const animalName = &quot;mave&quot;; console.log(animalName); //결과는 Uncaught SyntaxError: Identifier 'animalName' has already been declared. let과 똑같이 재선언을 못하고 에러를 내뱉는다. let도 그랬으니 여기까진 봐주자. 그렇다면 let에서는 가능했던 재할당은 어떨까? 다음 코드를 보자. const animalName = &quot;native&quot;; console.log(animalName); //결과는 native animalName = &quot;mave&quot;; console.log(animalName); //결과는 Uncaught TypeError: Assignment to constant variable. 한번 먹였으면 됬지 뭘 더 먹이려고 하냐면서 화를 내신다. 참 까탈스러운 분이다. 정리해보자면 let은 재선언은 불가능하지만 재할당은 가능하다. 그에 반해 const는 재할당도 안되고 재선언도 못한다. var의 호이스팅 문제로 인하여 let과 const변수선언이 ES6에서 등장했다고 서술했다. 방금 전 호이스팅 현상을 let과 const로 써보면 어떨까? 다음 코드에서는 한 눈으로 확인해보기 위하여 let과 const 둘 다 사용한 예제이다. name = &quot;abcd&quot;; //Uncaught ReferenceError: Cannot access 'name' before initialization. console.log(name); let name = &quot;Yeah!!!!!!!&quot;; animal = &quot;bat&quot;; //Uncaught ReferenceError: Cannot access 'animal' before initialization. console.log(animal); const animal = &quot;O.O&quot;; 호이스팅이고 뭐고 다 필요없고 아주 멋지게 당장 에러를 내뱉어 주신다. 정리 지금까지 ES5에서의 선언법 var와 ES6에서 새롭게 탑재된 선언법인 let과 const에 대해서 알아보았다. 정리해보자면 var와 let, const의 차이점은 아래의 표와 같다. 선언문 재선언 재할당 var 가능 가능 let 불가능 가능 const 불가능 불가능</summary>
      

      
      
    </entry>
  
</feed>
