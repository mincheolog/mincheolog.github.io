<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="/tag/typescript/feed.xml" rel="self" type="application/atom+xml" />
  <link href="/" rel="alternate" type="text/html" />
  <updated>2021-07-24T20:15:47+09:00</updated>
  <id>/tag/typescript/feed.xml</id>

  
  
  

  
    <title type="html">ArdoDulcis | </title>
  

  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">Type VS Interface</title>
      <link href="/typescript-type-vs-interface" rel="alternate" type="text/html" title="Type VS Interface" />
      <published>2021-07-21T09:00:00+09:00</published>
      <updated>2021-07-21T09:00:00+09:00</updated>
      <id>/typescript-type-vs-interface</id>
      <content type="html" xml:base="/typescript-type-vs-interface">&lt;h1 id=&quot;typescript-type-vs-interface&quot;&gt;TypeScript Type VS Interface&lt;/h1&gt;
&lt;p&gt;타입스크립트에서 타입을 정의하는 방법중 type 선언과 interface 선언이 있다. 개인적으로 공부하고 실무에서 쓰기까지 지금껏 type선언만으로도 문제없이 코딩을 해왔고 딱히 interface를 쓸 필요가 없었다. 특히나 실무에선 type선언으로만 코딩을 해왔기에 더욱 interface에 대해서 신경 쓸 일이 없던 것 같다. 그러던 어느날 팀원중 한분께서 type과 interface의 차이점, 어느때 쓰는게 제일 적당한지 설명을 듣고싶다고 하셨는데 type으로만 타입정의를 해왔던 나로써는 바로 정확한 대답을 할 수가 없었다. 이번일을 계기로 type과 interface의 특징 그리고 내가 개인적으로 생각하는 type과 interface의 쓰임새를 적어보고자 한다.
일단 type과 interface의 차이점을 보기위해 각각의 특징을 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;interface&quot;&gt;Interface&lt;/h2&gt;
&lt;p&gt;Interface는 아래와 같은 특징을 가진다.&lt;/p&gt;

&lt;h3 id=&quot;type-extends-가능-여부&quot;&gt;type extends 가능 여부&lt;/h3&gt;

&lt;p&gt;밑의 코드와 같이 문제없이 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPos2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPos3&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPos2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 결과&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
interface IPos3 {
  x: number;
  y: number;
  z: number;
}
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;ts파일내-같은-이름의-타입으로-선언시-에러-여부&quot;&gt;ts파일내 같은 이름의 타입으로 선언시 에러 여부&lt;/h3&gt;

&lt;p&gt;type을 자주써왔던 나로서는 가장 놀랬던 부분이다. type의 경우 에러가 나는 부분인데 interface의 경우 에러는 나지 않고 암묵적으로 머지된다.&lt;/p&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPos&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPos&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 결과&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
interface IPos {
  x: number;
  y: number;
  z: number;
}
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;class에-implements-가능-여부&quot;&gt;Class에 &lt;a href=&quot;#implements&quot;&gt;implements&lt;/a&gt; 가능 여부&lt;/h3&gt;
&lt;p&gt;가능하다.&lt;/p&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPerson&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPerson&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;교차-타입-유니언-타입-튜플-타입-정의-가능-여부&quot;&gt;교차 타입, 유니언 타입, 튜플 타입 정의 가능 여부&lt;/h3&gt;
&lt;p&gt;싹다 안된다.&lt;/p&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c1&quot;&gt;// Union&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPerson&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Intersection&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPerson&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 결과&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type. ts(2363)
*/&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Tuple 얘는 그냥 문법적으로 에러...&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPerson&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;mapped-types-가능-여부&quot;&gt;&lt;a href=&quot;#mapped-types&quot;&gt;Mapped Types&lt;/a&gt; 가능 여부&lt;/h3&gt;
&lt;p&gt;일단 결론부터 말하자면 에러 터진다. interface자체가 mapped type이용하여 타입을 매핑할수 없게 만들어졌기 때문이라는데, TypeScript 4.4버전부터 interface에도 mapped typed를 쓸 수 있게끔 된다고 한다. (&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/26797&quot;&gt;관련 이슈&lt;/a&gt;)
그럼 코드를 확인해보자.&lt;/p&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TBloodType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'O'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'A'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'B'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'AB'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IBloodInfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TBloodType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 결과&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
Error: A computed property name in an interface must refer to an expression whose type is a literal type or a 'unique symbol' type .ts(1169)
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;type&quot;&gt;Type&lt;/h2&gt;
&lt;p&gt;Type은 아래와 같은 특징을 가진다.&lt;/p&gt;

&lt;h3 id=&quot;extends-가능-여부&quot;&gt;extends 가능 여부&lt;/h3&gt;
&lt;p&gt;밑의 코드와 같이 교차타입을 만드는 방식으로 interface와 같은 extends를 구현할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPos3D&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 결과&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type IPos3D = {
  x: number;
  y: number;
  z: number;
}
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;ts파일내-같은-이름의-타입으로-선언시-에러-여부-1&quot;&gt;ts파일내 같은 이름의 타입으로 선언시 에러 여부&lt;/h3&gt;
&lt;p&gt;interface와 다르게 같은 이름으로 선언시 에러가 터진다.&lt;/p&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 결과&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
Error: Duplicate identifier 'IPos'. ts(2300)
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;class에-implements-가능-여부-1&quot;&gt;Class에 &lt;a href=&quot;#implements&quot;&gt;implements&lt;/a&gt; 가능 여부&lt;/h3&gt;
&lt;p&gt;가능하다&lt;/p&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TPerson&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IPerson&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;교차-타입-유니언-타입-튜플-타입-정의-가능-여부-1&quot;&gt;교차 타입, 유니언 타입, 튜플 타입 정의 가능 여부&lt;/h3&gt;

&lt;p&gt;가능하다.&lt;/p&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Union&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;OneOrTwo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'One'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Two'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Intersection&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;OneAndTwo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'One'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Two'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Tuple&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tuple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;mapped-types-가능-여부-1&quot;&gt;&lt;a href=&quot;#mapped-types&quot;&gt;Mapped Types&lt;/a&gt; 가능 여부&lt;/h3&gt;
&lt;p&gt;필자는 서브셋 유틸 타입을 만들거나 할때 자주 쓰는 편이다. 아래와 같이 구현이 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TBloodType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'O'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'A'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'B'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'AB'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TBloodTypeInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TBloodType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 결과&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type TBloodTypeInfo = {
  O: string;
  A: string;
  B: string;
  AB: string;
};
*/&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 깨알 코드! 유틸함수 Partial&amp;lt;Type&amp;gt;을 구현해보자&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Partial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;keyof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]?:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TBloodType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'O'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'A'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'B'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'AB'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TBloodTypeInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TBloodType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TBloodPartial&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Partial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;TBloodTypeInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 결과&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type TBloodPartial = {
  O?: string;
  A?: string;
  B?: string;
  AB?: string;
};
*/&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;언제-쓰는게-좋은가&quot;&gt;언제 쓰는게 좋은가&lt;/h2&gt;
&lt;p&gt;거의 케바케인거 같다. 게다가 TypeScript 로드맵에 4.4부터 interface에 대한 Mapped Types지원을 한다는게 있는거 보면 type과 interface에 대한 구분이 없어지지 않나… 라는 생각이 든다.
이 둘이 구분선이 없어졌을때 고려해야 한다고 하면 프로젝트 단위로 interface를 쓸것인지 type을 쓸것인지 그 규약만 정하면 되지 않을까? 추후엔 type과 interface에 대한 경계선이 무너지면 이 둘이 통합될거 같다는 생각도 든다. (그냥 개인적인 추측이다 ㅋㅋ)&lt;/p&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;이번 포스트를 쓰면서 implements의 개념이라던가 Tuple이 정확히 뭔지 알게 된 것같다. interface와 type의 차이점을 알아가면서 TypeScript 4.4부터는 interface도 Mapped types를 지원한다는 점도 알게되었다. 요즘 회사 모든 신규 프로젝트를 TypeScript로 진행하려고 했는데 Type을 쓸것인지 interface를 쓸것인지 규악을 정할때 여러모로 많은 참고가 된 것 같다. type으로도 충분히 interface의 상속을 모방할 수 있으며 implements도 가능하다는 점. 특히나 같은 ts파일내에서 같은 타입변수명으로 타입 정의를 할 경우 에러가 난다는점과 Tuple형을 정의 가능하다는 점에서 앞으로도 주로 type으로 타입정의를 할 것 같다.&lt;/p&gt;

&lt;h3 id=&quot;용어-해설&quot;&gt;용어 해설&lt;/h3&gt;
&lt;h4 id=&quot;tuple&quot;&gt;Tuple&lt;/h4&gt;
&lt;p&gt;TypeScript에서 Tuple은 배열에서 각 원소의 타입이 정확히 지정된 타입을 말한다. 만일 지정된 원소의 수나 타입이 정확하지 않을 경우 에러를 내준다.&lt;/p&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tuple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// OK&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tuple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// NG&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;array2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tuple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;implements&quot;&gt;implements&lt;/h4&gt;
&lt;p&gt;Java라는 언어에서 extends와 implements는 둘다 상속이라고 한다. Java에서 다중상속이 지원되지 않는다고 하는데 그걸 해결하기 위해 나온것이 implements. extends는 하나의 부모객체에서만 상속받을수 있으며 implements는 다중 상속 (여러 부모객체의 메소드나 프로퍼티를 상속받는다)이 가능하다고 한다. implements로 상속받을 경우 interface를 재정의 해야하는데 그 개념을 TypeScript로 가져온거 같다. implements는 그냥 객체에 대한 interface정의라고 보면 될거 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;참고 기사 원문&lt;/strong&gt;
&lt;a href=&quot;https://velog.io/@hkoo9329/%EC%9E%90%EB%B0%94-extends-implements-%EC%B0%A8%EC%9D%B4&quot;&gt;자바 extends, implements 차이&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;mapped-types&quot;&gt;Mapped Types&lt;/h4&gt;
&lt;p&gt;TypeScript에서 타입 정의를 할때 key in을 이용하여 만든 Type을 말한다. 개념적으로는 JavaScript에서 map키워드나 for in같은 문법으로 배열을 순회하여 새로운 결과값을 만드는 것과 비슷하다. (솔직히 유틸타입인 Record를 이용해서 구현가능한 부분이다.)&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;numbers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// numbers안의 숫자를 기반으로 각 요소에 2를 곱한 새로운 배열 요소를 만든다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newNumbers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 결과&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
[2, 4, 6]
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Mapped Types의 경우&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TNumbers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// UnionType의 TNumbers를 기반으로 새로운 타입을 만들어 반환한다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TNewNumbers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]?:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 결과&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type TNewNumbers = {
  1?: number;
  2?: number;
  3?: number;
}
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Record의 경우&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TNumbers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TNewNumbers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;TNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 결과&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type TNewNumbers = {
  1: number;
  2: number;
  3: number;
}
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>Ardo</name>
        
        
      </author>

      

      
        <category term="posts" />
      
        <category term="TypeScript" />
      
        <category term="FrontEnd" />
      

      
        <summary type="html">TypeScript Type VS Interface 타입스크립트에서 타입을 정의하는 방법중 type 선언과 interface 선언이 있다. 개인적으로 공부하고 실무에서 쓰기까지 지금껏 type선언만으로도 문제없이 코딩을 해왔고 딱히 interface를 쓸 필요가 없었다. 특히나 실무에선 type선언으로만 코딩을 해왔기에 더욱 interface에 대해서 신경 쓸 일이 없던 것 같다. 그러던 어느날 팀원중 한분께서 type과 interface의 차이점, 어느때 쓰는게 제일 적당한지 설명을 듣고싶다고 하셨는데 type으로만 타입정의를 해왔던 나로써는 바로 정확한 대답을 할 수가 없었다. 이번일을 계기로 type과 interface의 특징 그리고 내가 개인적으로 생각하는 type과 interface의 쓰임새를 적어보고자 한다. 일단 type과 interface의 차이점을 보기위해 각각의 특징을 알아보자. Interface Interface는 아래와 같은 특징을 가진다. type extends 가능 여부 밑의 코드와 같이 문제없이 가능하다. interface IPos2 { x: number; y: number; }; interface IPos3 extends IPos2 { z: number; }; // 결과 /* interface IPos3 { x: number; y: number; z: number; } */ ts파일내 같은 이름의 타입으로 선언시 에러 여부 type을 자주써왔던 나로서는 가장 놀랬던 부분이다. type의 경우 에러가 나는 부분인데 interface의 경우 에러는 나지 않고 암묵적으로 머지된다. interface IPos { x: number; y: number; }; interface IPos { z: number; }; // 결과 /* interface IPos { x: number; y: number; z: number; } */ Class에 implements 가능 여부 가능하다. interface IPerson { name: string; age: number; }; class Person implements IPerson { name = ''; age = 0; } 교차 타입, 유니언 타입, 튜플 타입 정의 가능 여부 싹다 안된다. // Union interface IPerson { age: number; } | { name: string; } // Intersection interface IPerson { age: number; } &amp;amp; { name: string; } // 결과 /* The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type. ts(2363) */ // Tuple 얘는 그냥 문법적으로 에러... interface IPerson [string, number] Mapped Types 가능 여부 일단 결론부터 말하자면 에러 터진다. interface자체가 mapped type이용하여 타입을 매핑할수 없게 만들어졌기 때문이라는데, TypeScript 4.4버전부터 interface에도 mapped typed를 쓸 수 있게끔 된다고 한다. (관련 이슈) 그럼 코드를 확인해보자. type TBloodType = 'O' | 'A' | 'B' | 'AB'; interface IBloodInfo { [key in TBloodType]: string; }; // 결과 /* Error: A computed property name in an interface must refer to an expression whose type is a literal type or a 'unique symbol' type .ts(1169) */ Type Type은 아래와 같은 특징을 가진다. extends 가능 여부 밑의 코드와 같이 교차타입을 만드는 방식으로 interface와 같은 extends를 구현할 수 있다. type IPos = { x: number; y: number; }; type IPos3D = IPos &amp;amp; { z: number; }; // 결과 /* type IPos3D = { x: number; y: number; z: number; } */ ts파일내 같은 이름의 타입으로 선언시 에러 여부 interface와 다르게 같은 이름으로 선언시 에러가 터진다. type IPos = { x: number; y: number; }; type IPos = { z: number; }; // 결과 /* Error: Duplicate identifier 'IPos'. ts(2300) */ Class에 implements 가능 여부 가능하다 type TPerson = { name: string; age: number; }; class Person implements IPerson { name = ''; age = 0; } 교차 타입, 유니언 타입, 튜플 타입 정의 가능 여부 가능하다. // Union type OneOrTwo = 'One' | 'Two'; // Intersection type OneAndTwo = 'One' &amp;amp; 'Two'; // Tuple type Tuple = [string, number]; Mapped Types 가능 여부 필자는 서브셋 유틸 타입을 만들거나 할때 자주 쓰는 편이다. 아래와 같이 구현이 가능하다. type TBloodType = 'O' | 'A' | 'B' | 'AB'; type TBloodTypeInfo = { [key in TBloodType]: string; }; // 결과 /* type TBloodTypeInfo = { O: string; A: string; B: string; AB: string; }; */ // 깨알 코드! 유틸함수 Partial&amp;lt;Type&amp;gt;을 구현해보자 type Partial&amp;lt;T&amp;gt; = { [K in keyof T]?: T[K]; }; type TBloodType = 'O' | 'A' | 'B' | 'AB'; type TBloodTypeInfo = { [key in TBloodType]: string; }; type TBloodPartial = Partial&amp;lt;TBloodTypeInfo&amp;gt;; // 결과 /* type TBloodPartial = { O?: string; A?: string; B?: string; AB?: string; }; */ 언제 쓰는게 좋은가 거의 케바케인거 같다. 게다가 TypeScript 로드맵에 4.4부터 interface에 대한 Mapped Types지원을 한다는게 있는거 보면 type과 interface에 대한 구분이 없어지지 않나… 라는 생각이 든다. 이 둘이 구분선이 없어졌을때 고려해야 한다고 하면 프로젝트 단위로 interface를 쓸것인지 type을 쓸것인지 그 규약만 정하면 되지 않을까? 추후엔 type과 interface에 대한 경계선이 무너지면 이 둘이 통합될거 같다는 생각도 든다. (그냥 개인적인 추측이다 ㅋㅋ) 마치며 이번 포스트를 쓰면서 implements의 개념이라던가 Tuple이 정확히 뭔지 알게 된 것같다. interface와 type의 차이점을 알아가면서 TypeScript 4.4부터는 interface도 Mapped types를 지원한다는 점도 알게되었다. 요즘 회사 모든 신규 프로젝트를 TypeScript로 진행하려고 했는데 Type을 쓸것인지 interface를 쓸것인지 규악을 정할때 여러모로 많은 참고가 된 것 같다. type으로도 충분히 interface의 상속을 모방할 수 있으며 implements도 가능하다는 점. 특히나 같은 ts파일내에서 같은 타입변수명으로 타입 정의를 할 경우 에러가 난다는점과 Tuple형을 정의 가능하다는 점에서 앞으로도 주로 type으로 타입정의를 할 것 같다. 용어 해설 Tuple TypeScript에서 Tuple은 배열에서 각 원소의 타입이 정확히 지정된 타입을 말한다. 만일 지정된 원소의 수나 타입이 정확하지 않을 경우 에러를 내준다. type Tuple = [string, number]; // OK const array: Tuple = ['a', 1]; // NG const array2: Tuple = [1, 'a', 3]; implements Java라는 언어에서 extends와 implements는 둘다 상속이라고 한다. Java에서 다중상속이 지원되지 않는다고 하는데 그걸 해결하기 위해 나온것이 implements. extends는 하나의 부모객체에서만 상속받을수 있으며 implements는 다중 상속 (여러 부모객체의 메소드나 프로퍼티를 상속받는다)이 가능하다고 한다. implements로 상속받을 경우 interface를 재정의 해야하는데 그 개념을 TypeScript로 가져온거 같다. implements는 그냥 객체에 대한 interface정의라고 보면 될거 같다. 참고 기사 원문 자바 extends, implements 차이 Mapped Types TypeScript에서 타입 정의를 할때 key in을 이용하여 만든 Type을 말한다. 개념적으로는 JavaScript에서 map키워드나 for in같은 문법으로 배열을 순회하여 새로운 결과값을 만드는 것과 비슷하다. (솔직히 유틸타입인 Record를 이용해서 구현가능한 부분이다.) const numbers = [1, 2, 3]; // numbers안의 숫자를 기반으로 각 요소에 2를 곱한 새로운 배열 요소를 만든다. const newNumbers = numbers.map((num) =&amp;gt; num * 2); // 결과 /* [2, 4, 6] */ Mapped Types의 경우 type TNumbers = 1 | 2 | 3; // UnionType의 TNumbers를 기반으로 새로운 타입을 만들어 반환한다. type TNewNumbers = { [key in TNumbers]?: number }; // 결과 /* type TNewNumbers = { 1?: number; 2?: number; 3?: number; } */ Record의 경우 type TNumbers = 1 | 2 | 3; type TNewNumbers = Record&amp;lt;TNumbers, number&amp;gt;; // 결과 /* type TNewNumbers = { 1: number; 2: number; 3: number; } */</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">타입스크립트 유틸 타입 - 2</title>
      <link href="/typescript-utility-types-2" rel="alternate" type="text/html" title="타입스크립트 유틸 타입 - 2" />
      <published>2021-02-07T09:00:00+09:00</published>
      <updated>2021-02-07T09:00:00+09:00</updated>
      <id>/typescript-utility-types-2</id>
      <content type="html" xml:base="/typescript-utility-types-2">&lt;h1 id=&quot;typescript-util-types-2&quot;&gt;TypeScript Util Types 2&lt;/h1&gt;

&lt;p&gt;이번 포스트는 전에 쓴 &lt;a href=&quot;https://ardodulcis.github.io/typescript-utility-types-1&quot;&gt;타입스크립트 유틸 타입 - 1&lt;/a&gt;에서 소개하지 못한 나머지 유틸 타입들을 알아볼까 한다. 이 포스트에서 찾는 유틸 타입이 없는 경우 전 포스트를 읽어보는걸 권한다.&lt;/p&gt;

&lt;h2 id=&quot;parameterstype&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Parameters&amp;lt;Type&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Parameters는 Type에 &lt;code class=&quot;highlighter-rouge&quot;&gt;typeof 함수명&lt;/code&gt;이나 함수선언식을 넣으면 함수에 쓰인 인수들을 추출하여 배열형태로 넘겨준다. 새로 만들어지는 함수에 기존 함수 인수의 타입을 상속받아서 구현하고 싶을때는 배열안의 타입을 Union형식으로 바꾸던가 해서 구현해야한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/utility-types.html#parameterstype&quot;&gt;TypeScript 공식 문서&lt;/a&gt;에 공개된 코드의 예. &lt;strong&gt;똑같은 예시로 쓰기엔 뭐해서 좀 바꿔봤다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TestFuncParams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Parameters&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;boolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// TestFuncParams 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type TestFuncParams = [a: number, b: string, c: boolean];
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기존 함수의 인수 타입을 상속받아서 새로운 함수를 만들고 싶을 때는 아래와 같이 구현하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;myFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Parameters로 만들어진 배열을 [number]로 Union (튜플) 형태로 바꾸어준다. 이 기법은 TypeScript 3.4이상에서만 지원된다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyFuncParams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Parameters&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;myFunc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// MyFuncParams는 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type MyFuncParams = string | {
  a: string;
  b: number;
  c: boolean;
};
*/&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Union형태로 바뀐 MyFuncParams에서 Exclude를 이용, 기존 함수의 인수인 option 인수의 타입을 빼준다.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;childFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Exclude&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;MyFuncParams&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;constructorparameterstype&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConstructorParameters&amp;lt;Type&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;ES6의 class문법에서 생성자 &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;를 이용해 인스턴스화 할때 넘겨주는 인수의 타입을 배열형식으로 넘겨준다. class만 되는건지 잘 모르겠는데 함수의 컨스트럭터로 했을땐 이상하게 타입 오류가 난다. (이해도가 낮아서 그런지 추후에 알게되면 다른 포스트에서 정리해보고 싶다.)&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;PersonConstructor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ConstructorParameters&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// PersonConstructor 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type PersonConstructor = [name: string, age: number];
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;returntypetype&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ReturnType&amp;lt;Type&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;ReturnType은 함수의 반환 값의 타입을 반환하여 새로운 타입으로 만들어준다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;TestFuncParams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ReturnType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;boolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// type TestFuncParams = number;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;myFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MyFuncReturn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ReturnType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;myFunc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// type MyFuncReturn = number;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getSquareInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SquareInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ReturnType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getSquareInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*
type SquareInfo = {
  width: number;
  height: number;
};
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;instancetypetype&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;InstanceType&amp;lt;Type&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;클래스 생성자의 인스턴스 타입을 반환해준다. 정확히 어떤때 쓰는지 잘 모르겠다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;PersonIns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;InstanceType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 새롭게 만들어진 PersonIns 타입은 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type PersonIns = Person;
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;thisparametertypetype&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThisParameterType&amp;lt;Type&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;ThisParameterType은 객체가 가진 this 타입을 반환해준다. 일단 예제를 보자. 예시는 언제어디서나 예시로 자주 쓰이는 카운터를 예로 들었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의. 해당 유틸 타입은 &lt;code class=&quot;highlighter-rouge&quot;&gt;--strictFunctionTypes&lt;/code&gt;이 설정되어있을때만 제대로 동작한다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;initCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;dec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;showCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;initCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;dec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;showCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CounterThis&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ThisParameterType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 새롭게 만들어진 CounterThis 타입은 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type CounterThis = {
  counter: number;
};
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;omitthisparametertype&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OmitThisParameter&amp;lt;Type&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;OmitThisParameter는 객체가 가진 this 타입을 제거한 타입을 반환해준다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의. 해당 유틸 타입은 &lt;code class=&quot;highlighter-rouge&quot;&gt;--strictFunctionTypes&lt;/code&gt;이 설정되어있을때만 제대로 동작한다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;initCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;dec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;showCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;initCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;dec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;showCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;OmitThisParameter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 새롭게 만들어진 CounterThis 타입은 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type Counter = (initCount: number) =&amp;gt; {
  inc: () =&amp;gt; void;
  dec: () =&amp;gt; void;
  showCount: () =&amp;gt; void;
};
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;thistypetype&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThisType&amp;lt;Type&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;객체나 함수내에서 참조되는 this의 타입을 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의. 해당 유틸타입은 &lt;code class=&quot;highlighter-rouge&quot;&gt;-noImplicitThis&lt;/code&gt;이 설정되어있어야 제대로 동작한다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AnimalInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ThisType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AnimalInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;

&lt;p&gt;TypeScript의 모든 유틸 타입을 알아보았다. 개인적인 생각이지만 ThisType이나 Parameters외에는 거의 쓰일일이 없을것 같다. 필자도 아직 위의 유틸타입들은 제대로 써본적이 없는터라 아직 모르는게 많고 어떤 상황에서 활용을 해야되는지 확실하게는 모르겠지만, 사이드 프로젝트나 회사에서 TypeScript로 코딩하다가 쓰게 된다면 추후에 하나하나 정리해 나갈 것 같다.
정리해보니 딱히 이렇다 할 노하우나 그런게 없는거 같아 아쉽지만 이 글을 보고 아~ 대충 이런거구나 정도로 봐준다면 너무 기쁠 것 같다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Ardo</name>
        
        
      </author>

      

      
        <category term="posts" />
      
        <category term="TypeScript" />
      
        <category term="FrontEnd" />
      

      
        <summary type="html">TypeScript Util Types 2 이번 포스트는 전에 쓴 타입스크립트 유틸 타입 - 1에서 소개하지 못한 나머지 유틸 타입들을 알아볼까 한다. 이 포스트에서 찾는 유틸 타입이 없는 경우 전 포스트를 읽어보는걸 권한다. Parameters&amp;lt;Type&amp;gt; Parameters는 Type에 typeof 함수명이나 함수선언식을 넣으면 함수에 쓰인 인수들을 추출하여 배열형태로 넘겨준다. 새로 만들어지는 함수에 기존 함수 인수의 타입을 상속받아서 구현하고 싶을때는 배열안의 타입을 Union형식으로 바꾸던가 해서 구현해야한다. TypeScript 공식 문서에 공개된 코드의 예. 똑같은 예시로 쓰기엔 뭐해서 좀 바꿔봤다. type TestFuncParams = Parameters&amp;lt;(a: number, b: string, c: boolean) =&amp;gt; void&amp;gt;; // TestFuncParams 밑의 결과와 같다. /* type TestFuncParams = [a: number, b: string, c: boolean]; */ 기존 함수의 인수 타입을 상속받아서 새로운 함수를 만들고 싶을 때는 아래와 같이 구현하면 된다. function myFunc(params: { a: string; b: number; c: boolean }, option: string): number { const { a, b, c } = params; return b; } // Parameters로 만들어진 배열을 [number]로 Union (튜플) 형태로 바꾸어준다. 이 기법은 TypeScript 3.4이상에서만 지원된다. type MyFuncParams = Parameters&amp;lt;typeof myFunc&amp;gt;[number]; // MyFuncParams는 밑의 결과와 같다. /* type MyFuncParams = string | { a: string; b: number; c: boolean; }; */ // Union형태로 바뀐 MyFuncParams에서 Exclude를 이용, 기존 함수의 인수인 option 인수의 타입을 빼준다. function childFunc(params: Exclude&amp;lt;MyFuncParams, string&amp;gt;): string { const { a, b, c } = params; return a; } ConstructorParameters&amp;lt;Type&amp;gt; ES6의 class문법에서 생성자 new를 이용해 인스턴스화 할때 넘겨주는 인수의 타입을 배열형식으로 넘겨준다. class만 되는건지 잘 모르겠는데 함수의 컨스트럭터로 했을땐 이상하게 타입 오류가 난다. (이해도가 낮아서 그런지 추후에 알게되면 다른 포스트에서 정리해보고 싶다.) class Person { name: string; age: number; constructor(name: string, age: number) { this.name = name; this.age = age; } } type PersonConstructor = ConstructorParameters&amp;lt;typeof Person&amp;gt;; // PersonConstructor 밑의 결과와 같다. /* type PersonConstructor = [name: string, age: number]; */ ReturnType&amp;lt;Type&amp;gt; ReturnType은 함수의 반환 값의 타입을 반환하여 새로운 타입으로 만들어준다. type TestFuncParams = ReturnType&amp;lt;(a: number, b: string, c: boolean) =&amp;gt; number&amp;gt;; // type TestFuncParams = number; function myFunc(): number { return 1; } type MyFuncReturn = ReturnType&amp;lt;typeof myFunc&amp;gt;; // type MyFuncReturn = number; function getSquareInfo(): { width: number, height: number } { return { width: 10, height: 30, }; } type SquareInfo = ReturnType&amp;lt;typeof getSquareInfo&amp;gt;; /* type SquareInfo = { width: number; height: number; }; */ InstanceType&amp;lt;Type&amp;gt; 클래스 생성자의 인스턴스 타입을 반환해준다. 정확히 어떤때 쓰는지 잘 모르겠다. class Person { name: string; age: number; constructor(name: string, age: number) { this.name = name; this.age = age; } } type PersonIns = InstanceType&amp;lt;typeof Person&amp;gt;; // 새롭게 만들어진 PersonIns 타입은 밑의 결과와 같다. /* type PersonIns = Person; */ ThisParameterType&amp;lt;Type&amp;gt; ThisParameterType은 객체가 가진 this 타입을 반환해준다. 일단 예제를 보자. 예시는 언제어디서나 예시로 자주 쓰이는 카운터를 예로 들었다. 주의. 해당 유틸 타입은 --strictFunctionTypes이 설정되어있을때만 제대로 동작한다. function counter( this: { count: number }, initCount: number ): { inc: () =&amp;gt; void, dec: () =&amp;gt; void, showCount: () =&amp;gt; void, } { this.count = initCount; return { inc: () =&amp;gt; this.count++, dec: () =&amp;gt; this.count--, showCount: () =&amp;gt; console.log(this.count), }; } type CounterThis = ThisParameterType&amp;lt;typeof counter&amp;gt;; // 새롭게 만들어진 CounterThis 타입은 밑의 결과와 같다. /* type CounterThis = { counter: number; }; */ OmitThisParameter&amp;lt;Type&amp;gt; OmitThisParameter는 객체가 가진 this 타입을 제거한 타입을 반환해준다. 주의. 해당 유틸 타입은 --strictFunctionTypes이 설정되어있을때만 제대로 동작한다. function counter( this: { count: number }, initCount: number ): { inc: () =&amp;gt; void, dec: () =&amp;gt; void, showCount: () =&amp;gt; void, } { this.count = initCount; return { inc: () =&amp;gt; this.count++, dec: () =&amp;gt; this.count--, showCount: () =&amp;gt; console.log(this.count), }; } type Counter = OmitThisParameter&amp;lt;typeof counter&amp;gt;; // 새롭게 만들어진 CounterThis 타입은 밑의 결과와 같다. /* type Counter = (initCount: number) =&amp;gt; { inc: () =&amp;gt; void; dec: () =&amp;gt; void; showCount: () =&amp;gt; void; }; */ ThisType&amp;lt;Type&amp;gt; 객체나 함수내에서 참조되는 this의 타입을 적용할 수 있다. 주의. 해당 유틸타입은 -noImplicitThis이 설정되어있어야 제대로 동작한다. type AnimalInfo = ThisType&amp;lt;{ name: string, category: string, }&amp;gt;; const animal: AnimalInfo &amp;amp; { say: () =&amp;gt; void } = { say() { console.log(this.name); }, }; 마치며 TypeScript의 모든 유틸 타입을 알아보았다. 개인적인 생각이지만 ThisType이나 Parameters외에는 거의 쓰일일이 없을것 같다. 필자도 아직 위의 유틸타입들은 제대로 써본적이 없는터라 아직 모르는게 많고 어떤 상황에서 활용을 해야되는지 확실하게는 모르겠지만, 사이드 프로젝트나 회사에서 TypeScript로 코딩하다가 쓰게 된다면 추후에 하나하나 정리해 나갈 것 같다. 정리해보니 딱히 이렇다 할 노하우나 그런게 없는거 같아 아쉽지만 이 글을 보고 아~ 대충 이런거구나 정도로 봐준다면 너무 기쁠 것 같다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">타입스크립트 유틸 타입 - 1</title>
      <link href="/typescript-utility-types-1" rel="alternate" type="text/html" title="타입스크립트 유틸 타입 - 1" />
      <published>2021-01-24T09:00:00+09:00</published>
      <updated>2021-01-24T09:00:00+09:00</updated>
      <id>/typescript-utility-types-1</id>
      <content type="html" xml:base="/typescript-utility-types-1">&lt;h1 id=&quot;oh-my-typescript-utility-type&quot;&gt;Oh My TypeScript Utility Type.&lt;/h1&gt;

&lt;p&gt;TypeScript를 처음접하고 Type을 지정해주면서 쓸 때 중복되는 타입객체를 만드는경우가 허다 했다. 특히나 API에서 받아오는 데이터 타입을 지정하고 그 데이터를 기반으로 form에 담아 갱신된 데이터를 보낼떄 그 Request데이터도 따로 타입을 지정해줬었다. 당시 TypeScript의 유틸 타입이 뭔지도 몰랐고 C나 Java를 거의 안만지다 싶이 살아왔기에 제네릭이 뭔지도 몰라서 보면 개발 D-Day는 오고 개발은 해야되는데 머리속만 복잡해져서 넘겼었다. 최근에 와서야 여유가 생겨서 핸드북 좀 보고 있는데 TypeScript 유틸 타입이 엄청나게 좋은걸 깨닫고 정리 좀 해보려고 한다.
덕분에 지금은 유틸타입을써서 재이용하여 타입을 지정하고 하고 있는데 전에썼던 Type정의부분을 전부 다 리팩터 해야되지 않나… 라는 고민이 생겼다 ㅋㅋ;;
TypeScript에서 제공하는 유틸이 거의 20개에 육박한다. 솔직히 다 숙지하고 쓰기에는 자주 않쓰는것도 많아서 1편에선 자주 쓰는 유틸타입을 정리하고 2편에서 나머지를 다뤄보고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;partialtype&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Partial&amp;lt;Type&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;필수 타입을 그냥 싸그리 필수가 아닌 타입으로 바꿔서 Type을 만들어준다. (기존에 있던 필수가 아닌 타입은 그대로 유지된다.)&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NoReuiredPerson&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Partial&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// NoReuiredPerson은 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type Person = {
  name?: string;
  age?: number;
};
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;readonlytype&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Readonly&amp;lt;Type&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;싸그리 Readonly로 바꾸어서 새롭게 Type을 만들어준다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;red&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ImmutableColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Readonly&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ImmutableColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;red&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// property에 새로운 값으로 할당하려 할 경우 TypeScript에서 에러를 내뱉는다.&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;Red&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;blue&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Cannot assign to 'title' because it is a read-only property.&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// ImmutableColor는 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type Color = {
  readonly property: 'red';
};
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;recordkeystype&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Record&amp;lt;Keys,Type&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Keys에는 새롭게 만들어질 객체의 key를 Type에는 객체의 value값을 의미한다. 즉 key와 value를 갖는 객체의 type을 만들어준다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;BookTitle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;BookInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Fantasy&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Action&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Comic&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;price&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Book&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;BookTitle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;BookInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Book&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Action&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;price&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}),&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Comic&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;price&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 새롭게 만들어진 Record타입인 Book은 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type Book = {
  [key: string]: {
    category: 'Fantasy' | 'Action' | 'Comic';
    price: number;
  };
};
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;picktype-keys&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Pick&amp;lt;Type, Keys&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Pick은 기존 Type객체를 기준으로 Keys에서 지정한 key값만 뽑아 새로운 Type객체를 만들어준다. key값의 지정은 Union형식으로 지정한다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Form&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;RequestParams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Pick&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Form&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'email'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'password'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;reqParams&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;RequestParams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'eeefa'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'pick test'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 새롭게 만들어진 RequestParams의 타입은 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type RequestParams = {
  email: string;
  password: string;
};
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;omittype-keys&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Omit&amp;lt;Type, Keys&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Omit은 &lt;a href=&quot;#picktype-keys&quot;&gt;Pick&lt;/a&gt;의 반대 개념이다. 기존 Type객체를 기준으로 Keys에서 지정한 key값을 제외한 모든 key값을 뽑아 새로운 Type객체를 만들어준다. Pick과 마찬가지로 key값의 지정은 Union형식으로 지정한다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Form&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;RequestParams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Omit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Form&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'name'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;reqParams&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;RequestParams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'eeefa'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;password&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'omit test'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 새롭게 만들어진 RequestParams의 타입은 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type RequestParams = {
  email: string;
  password: string;
};
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;excludetype-excludedunion&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Exclude&amp;lt;Type, ExcludedUnion&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Exclude는 Type에서 ExcludedUnion에 지정된 타입을 Type에서 제외하여 새로운 Type으로 만들어준다. Union타입만 넣을수 있다. Union이 아닌 객체타입으로 새롭게 만들경우에는 Record를 이용한다던지 좀 생각을해줘야한다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ExcludeType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Exclude&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;exclude&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ExcludeType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 새롭게 만들어진 ExcludeType 타입은 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type ExcludeType = 'c';
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Exclude를 이용하여 새로운 객체 타입을 만들고 싶을 경우. 객체 A와 B의 프로퍼티를 비교하여 겹치는 부분만 제외 A의 필요한 프로퍼티만 추출할때 유용하다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Exclude안에 keyof를 이용하여 type A과 type B를 union형식으로 추출, Record를 이용하여 새로운 Type객체를 만들어준다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ObjectExcludeType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Exclude&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;keyof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;keyof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;objectExclude&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ObjectExcludeType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hello!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 새롭게 만들어진 ObjectExcludeType 타입은 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type ObjectExcludeType = {
  e: string;
};
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;extracttype-union&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Extract&amp;lt;Type, Union&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Extract의 경우 &lt;a href=&quot;#excludetype-excludedunion&quot;&gt;Exclude&lt;/a&gt;와는 반대개념이다. Type에서 Union에 지정한 타입을 Type에서 추출, 새로운 Type으로 만들어준다. 물론, Union에는 Union타입만 넣을수있다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ExtractType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Extract&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;extract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ExtractType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;extract2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ExtractType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 새롭게 만들어진 ExtractType 타입은 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type ExcludeType = 'a' | 'b';
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;#excludetype-excludedunion&quot;&gt;Exclude&lt;/a&gt;의 반대로 A 객체와 B 객체를 비교해서 겹치는 부분을 A 객체를 기준으로 새로운 Type을 만들고 싶을 경우 아래와 같이 쓸 수있다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Exclude안에 keyof를 이용하여 type A과 type B를 union형식으로 추출, Record를 이용하여 새로운 Type객체를 만들어준다.&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ObjectExtractType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Record&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Extract&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;keyof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;keyof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;objectExclude&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ObjectExtractType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hello!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;world!&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 새롭게 만들어진 ObjectExtractType 타입은 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type ObjectExtractType = {
  a: string;
  b: string;
};
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;nonnullabletype&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NonNullable&amp;lt;Type&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;NonNullable은 Type안에 있는 ‘undefined’와 ‘null’타입을 제거한 타입을 만들어준다. 솔직히 요래 돌려쓰기보단 &lt;a href=&quot;#requiredtype&quot;&gt;Required&lt;/a&gt;을 쓰는게 훨신 직관적이니 상황에 따라 잘 판단하여 쓰는게 좋다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주의. 명시적으로 null타입을 넣은 타입도 null이 제거된 타입으로 바뀌니 조심해야한다. 이때는 &lt;a href=&quot;#requiredtype&quot;&gt;Required&lt;/a&gt; 써주도록 하자.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NonNullable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NonNullable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Age&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// ok&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;human1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;kim&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// NG TS2322: Type 'null' is not assignable to type 'string'&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;human2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 새롭게 만들어진 Person 타입은 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type Person = {
  name: string;
  age: number;
};
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;requiredtype&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Required&amp;lt;Type&amp;gt;&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Required는 &lt;a href=&quot;#partialtype&quot;&gt;Partial&lt;/a&gt;과 반대 개념이다 Type안에 있는 모든 undefined값을 가지는 타입, 즉 필수가 아닌 타입을 싸그리 필수 타입으로 새롭게 만들어준다.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ReuiredAnimalInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Required&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// ReuiredAnimalInfo 밑의 결과와 같다.&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
type ReuiredAnimalInfo = {
  name: string;
  age: number;
};
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;

&lt;p&gt;이번 포스트에선 TypeScript로 코딩하면서 자주 쓰일것 같은 유틸 타입을 정리 해보았다. (진짜 Omit이나 Pick은 정말 많이 쓰인다.) 솔직히 이런 유틸 타입이 없어도 그에 맞는 타입을 만들어서 박으면 그만이다. 그러나 재사용성의 측면이나 유지, 보수 측면에서 본다면 여간 안좋은게 아니다. 예를 들면 유저정보를 편집하는 화면에서 초기화할때 요청하는 API의 파라메터와 갱신 된 정보를 보낼때 API의 파라메터가 같다. 물론 받아온 정보를 갱신하면 그 정보를 그대로 서버로 보내기때문에 유저 정보를 받아올 때의 파라메터를 정의해놓은 Type과 갱신 된 정보를 보낼때의 파라메터를 정의해놓은 Type이 있는데 이것도 같다. 이런 상황에서 서버쪽에서 받는 Type이 변경되어 프론트엔드쪽의 Type을 수정하게 된다고 하면 유저 정보를 받아올때 Type과 갱신된 정보를 보내는 Type을 둘다 수정해줘야 한다. 개발자에겐 얼마나 귀찮은 일인지 모른다. 더욱이 프로젝트가 큰 규모에서 이런 상황이 오면 수정해야될 부분을 싸그리 찾아야 된다.
TypeScript로 개발할때도 정의해놓은 Type의 재사용성을 염두에 두고 개발을 한다면 이런 불상사는 없을것이라 생각되며 유지, 보수하는 개발자가 본다면 얼마나 고마운 일인지 모른다. 그리고 하나 더 좋은 점은 유틸 타입을 쓰면 뭔가 TypeScript를 만질줄 알아보인다 ㅋㅋ TypeScript로 개발하는 모든 프론트엔드 개발자분들께 이 글을 바친다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Ardo</name>
        
        
      </author>

      

      
        <category term="posts" />
      
        <category term="TypeScript" />
      
        <category term="FrontEnd" />
      

      
        <summary type="html">Oh My TypeScript Utility Type. TypeScript를 처음접하고 Type을 지정해주면서 쓸 때 중복되는 타입객체를 만드는경우가 허다 했다. 특히나 API에서 받아오는 데이터 타입을 지정하고 그 데이터를 기반으로 form에 담아 갱신된 데이터를 보낼떄 그 Request데이터도 따로 타입을 지정해줬었다. 당시 TypeScript의 유틸 타입이 뭔지도 몰랐고 C나 Java를 거의 안만지다 싶이 살아왔기에 제네릭이 뭔지도 몰라서 보면 개발 D-Day는 오고 개발은 해야되는데 머리속만 복잡해져서 넘겼었다. 최근에 와서야 여유가 생겨서 핸드북 좀 보고 있는데 TypeScript 유틸 타입이 엄청나게 좋은걸 깨닫고 정리 좀 해보려고 한다. 덕분에 지금은 유틸타입을써서 재이용하여 타입을 지정하고 하고 있는데 전에썼던 Type정의부분을 전부 다 리팩터 해야되지 않나… 라는 고민이 생겼다 ㅋㅋ;; TypeScript에서 제공하는 유틸이 거의 20개에 육박한다. 솔직히 다 숙지하고 쓰기에는 자주 않쓰는것도 많아서 1편에선 자주 쓰는 유틸타입을 정리하고 2편에서 나머지를 다뤄보고자 한다. Partial&amp;lt;Type&amp;gt; 필수 타입을 그냥 싸그리 필수가 아닌 타입으로 바꿔서 Type을 만들어준다. (기존에 있던 필수가 아닌 타입은 그대로 유지된다.) type Person = { name: string, age: number, }; type NoReuiredPerson = Partial&amp;lt;Person&amp;gt;; // NoReuiredPerson은 밑의 결과와 같다. /* type Person = { name?: string; age?: number; }; */ Readonly&amp;lt;Type&amp;gt; 싸그리 Readonly로 바꾸어서 새롭게 Type을 만들어준다. type Color = { property: &quot;red&quot;, }; type ImmutableColor = Readonly&amp;lt;Color&amp;gt;; const Red: ImmutableColor = { property: &quot;red&quot;, }; // property에 새로운 값으로 할당하려 할 경우 TypeScript에서 에러를 내뱉는다. Red.property = &quot;blue&quot;; // Cannot assign to 'title' because it is a read-only property. // ImmutableColor는 밑의 결과와 같다. /* type Color = { readonly property: 'red'; }; */ Record&amp;lt;Keys,Type&amp;gt; Keys에는 새롭게 만들어질 객체의 key를 Type에는 객체의 value값을 의미한다. 즉 key와 value를 갖는 객체의 type을 만들어준다. type BookTitle = string; type BookInfo = { category: &quot;Fantasy&quot; | &quot;Action&quot; | &quot;Comic&quot;, price: number, }; type Book = Record&amp;lt;BookTitle, BookInfo&amp;gt;; const items: Book[] = [ (a: { category: &quot;Action&quot;, price: 12000, }), (b: { category: &quot;Comic&quot;, price: 10000, }), ]; // 새롭게 만들어진 Record타입인 Book은 밑의 결과와 같다. /* type Book = { [key: string]: { category: 'Fantasy' | 'Action' | 'Comic'; price: number; }; }; */ Pick&amp;lt;Type, Keys&amp;gt; Pick은 기존 Type객체를 기준으로 Keys에서 지정한 key값만 뽑아 새로운 Type객체를 만들어준다. key값의 지정은 Union형식으로 지정한다. type Form = { name: string; email: string; password: string; }; type RequestParams = Pick&amp;lt;Form, 'email' | 'password'&amp;gt;; const reqParams: RequestParams = { email: 'eeefa'; password: 'pick test'; }; // 새롭게 만들어진 RequestParams의 타입은 밑의 결과와 같다. /* type RequestParams = { email: string; password: string; }; */ Omit&amp;lt;Type, Keys&amp;gt; Omit은 Pick의 반대 개념이다. 기존 Type객체를 기준으로 Keys에서 지정한 key값을 제외한 모든 key값을 뽑아 새로운 Type객체를 만들어준다. Pick과 마찬가지로 key값의 지정은 Union형식으로 지정한다. type Form = { name: string; email: string; password: string; }; type RequestParams = Omit&amp;lt;Form, 'name'&amp;gt;; const reqParams: RequestParams = { email: 'eeefa'; password: 'omit test'; }; // 새롭게 만들어진 RequestParams의 타입은 밑의 결과와 같다. /* type RequestParams = { email: string; password: string; }; */ Exclude&amp;lt;Type, ExcludedUnion&amp;gt; Exclude는 Type에서 ExcludedUnion에 지정된 타입을 Type에서 제외하여 새로운 Type으로 만들어준다. Union타입만 넣을수 있다. Union이 아닌 객체타입으로 새롭게 만들경우에는 Record를 이용한다던지 좀 생각을해줘야한다. type A = &quot;a&quot; | &quot;b&quot; | &quot;c&quot;; type B = &quot;a&quot; | &quot;b&quot; | &quot;e&quot;; type ExcludeType = Exclude&amp;lt;A, B&amp;gt;; const exclude: ExcludeType = &quot;c&quot;; // 새롭게 만들어진 ExcludeType 타입은 밑의 결과와 같다. /* type ExcludeType = 'c'; */ Exclude를 이용하여 새로운 객체 타입을 만들고 싶을 경우. 객체 A와 B의 프로퍼티를 비교하여 겹치는 부분만 제외 A의 필요한 프로퍼티만 추출할때 유용하다. type A = { a: string; b: string; e: string; }; type B = { a: string; b: string; d: string; }; // Exclude안에 keyof를 이용하여 type A과 type B를 union형식으로 추출, Record를 이용하여 새로운 Type객체를 만들어준다. type ObjectExcludeType = Record&amp;lt;Exclude&amp;lt;keyof A, keyof B&amp;gt;, string&amp;gt;; const objectExclude: ObjectExcludeType = { e: &quot;hello!&quot;, }; // 새롭게 만들어진 ObjectExcludeType 타입은 밑의 결과와 같다. /* type ObjectExcludeType = { e: string; }; */ Extract&amp;lt;Type, Union&amp;gt; Extract의 경우 Exclude와는 반대개념이다. Type에서 Union에 지정한 타입을 Type에서 추출, 새로운 Type으로 만들어준다. 물론, Union에는 Union타입만 넣을수있다. type A = &quot;a&quot; | &quot;b&quot; | &quot;c&quot;; type B = &quot;a&quot; | &quot;b&quot; | &quot;e&quot;; type ExtractType = Extract&amp;lt;A, B&amp;gt;; const extract: ExtractType = &quot;a&quot;; const extract2: ExtractType = &quot;b&quot;; // 새롭게 만들어진 ExtractType 타입은 밑의 결과와 같다. /* type ExcludeType = 'a' | 'b'; */ Exclude의 반대로 A 객체와 B 객체를 비교해서 겹치는 부분을 A 객체를 기준으로 새로운 Type을 만들고 싶을 경우 아래와 같이 쓸 수있다. type A = { a: string; b: string; e: string; }; type B = { a: string; b: string; d: string; }; // Exclude안에 keyof를 이용하여 type A과 type B를 union형식으로 추출, Record를 이용하여 새로운 Type객체를 만들어준다. type ObjectExtractType = Record&amp;lt;Extract&amp;lt;keyof A, keyof B&amp;gt;, string&amp;gt;; const objectExclude: ObjectExtractType = { a: &quot;hello!&quot;, b: &quot;world!&quot; }; // 새롭게 만들어진 ObjectExtractType 타입은 밑의 결과와 같다. /* type ObjectExtractType = { a: string; b: string; }; */ NonNullable&amp;lt;Type&amp;gt; NonNullable은 Type안에 있는 ‘undefined’와 ‘null’타입을 제거한 타입을 만들어준다. 솔직히 요래 돌려쓰기보단 Required을 쓰는게 훨신 직관적이니 상황에 따라 잘 판단하여 쓰는게 좋다. 주의. 명시적으로 null타입을 넣은 타입도 null이 제거된 타입으로 바뀌니 조심해야한다. 이때는 Required 써주도록 하자. type Name = string | undefined | null; type Age = number | null; type Person = { name: NonNullable&amp;lt;Name&amp;gt;, age: NonNullable&amp;lt;Age&amp;gt;, }; // ok const human1: Person = { name: &quot;kim&quot;, age: 20, }; // NG TS2322: Type 'null' is not assignable to type 'string' const human2: Person = { name: null, age: 20, }; // 새롭게 만들어진 Person 타입은 밑의 결과와 같다. /* type Person = { name: string; age: number; }; */ Required&amp;lt;Type&amp;gt; Required는 Partial과 반대 개념이다 Type안에 있는 모든 undefined값을 가지는 타입, 즉 필수가 아닌 타입을 싸그리 필수 타입으로 새롭게 만들어준다. type Animal = { name: string, age?: number, }; type ReuiredAnimalInfo = Required&amp;lt;Animal&amp;gt;; // ReuiredAnimalInfo 밑의 결과와 같다. /* type ReuiredAnimalInfo = { name: string; age: number; }; */ 마치며 이번 포스트에선 TypeScript로 코딩하면서 자주 쓰일것 같은 유틸 타입을 정리 해보았다. (진짜 Omit이나 Pick은 정말 많이 쓰인다.) 솔직히 이런 유틸 타입이 없어도 그에 맞는 타입을 만들어서 박으면 그만이다. 그러나 재사용성의 측면이나 유지, 보수 측면에서 본다면 여간 안좋은게 아니다. 예를 들면 유저정보를 편집하는 화면에서 초기화할때 요청하는 API의 파라메터와 갱신 된 정보를 보낼때 API의 파라메터가 같다. 물론 받아온 정보를 갱신하면 그 정보를 그대로 서버로 보내기때문에 유저 정보를 받아올 때의 파라메터를 정의해놓은 Type과 갱신 된 정보를 보낼때의 파라메터를 정의해놓은 Type이 있는데 이것도 같다. 이런 상황에서 서버쪽에서 받는 Type이 변경되어 프론트엔드쪽의 Type을 수정하게 된다고 하면 유저 정보를 받아올때 Type과 갱신된 정보를 보내는 Type을 둘다 수정해줘야 한다. 개발자에겐 얼마나 귀찮은 일인지 모른다. 더욱이 프로젝트가 큰 규모에서 이런 상황이 오면 수정해야될 부분을 싸그리 찾아야 된다. TypeScript로 개발할때도 정의해놓은 Type의 재사용성을 염두에 두고 개발을 한다면 이런 불상사는 없을것이라 생각되며 유지, 보수하는 개발자가 본다면 얼마나 고마운 일인지 모른다. 그리고 하나 더 좋은 점은 유틸 타입을 쓰면 뭔가 TypeScript를 만질줄 알아보인다 ㅋㅋ TypeScript로 개발하는 모든 프론트엔드 개발자분들께 이 글을 바친다.</summary>
      

      
      
    </entry>
  
</feed>
